<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>org-page</title>
    <link>http://tsubasawp.github.io/</link>
    <description>static site generator</description>
    <pubDate>Sun, 31 Jul 2016 11:02:48 CST</pubDate>
    <lastBuildDate>Sun, 31 Jul 2016 11:02:48 CST</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>Org-page static site generator (https://github.com/kelvinh/org-page)</generator>
    <item>
      <title>SICP-CH3 模块化,对象和状态</title>
      <link>http://tsubasawp.github.io/blog/2016/06/20/sicp-ch3</link>
      <description><![CDATA[sicp第三章,模块化,对象和状态]]></description>
      <pubDate>2016-07-31</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/06/20/sicp-ch3</guid>
    </item>
    <item>
      <title>Untitled</title>
      <link>http://tsubasawp.github.io/blog/2016/07/31/untitled/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Untitled</h1>
<p>
缩略语和关键术语定义
如果交底书中使用了腾讯内部特有的缩略语或自定义的名词，请进行解释。
UI: User Interface(用户交互界面)的缩写.
UI编辑器: 用于给游戏开发人员设计UI, 并导出程序可识别的数据结构的工具.
UI元素: 用户交互界面中的最小单位,比如一个按钮,一张图片.
Unity3D: 是一个用于创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的综合型创作工具.
UGUI: Unity3D引擎内置的UI框架.
i2d引擎: 自研的跨平台游戏引擎.
QT框架:1991年由奇趣科技开发的跨平台C++图形用户界面应用程序开发框架.
</p>

<p>
1、*发明点概述
此部分将主要作为评审专家评审的依据，请简要提炼发明的核心内容、阐述采用的关键技术和创新方法，300字左右。
UI(用户交互界面)是游戏产品的重要组成部分,好的UI不仅能使游戏风格变得有品味，还能让游戏的操作变得舒适.
UI往往由一系列图片和可交互元素(比如按钮,输入框)组合而成,在游戏制作中,我们往往用文本文件来记录UI的排版信息,以供程序解析加载.
另一方面,UI的排版往往对艺术性有较高要求,所以前期的设计工作会交由专业美术人员进行.
但是,美术人员的设计结果以图片形式输出,而最终游戏程序需要将图片中的信息转化成文本形式,这个步骤一定需要工具来辅助进行,这类工具就是UI编辑器.
几乎每一种游戏引擎都会配备自己的UI编辑器,本发明实现了工作室自研i2d游戏引擎引擎UI编辑器.
</p>

<p>
关键技术：实现i2d引擎UI文件的多层结构.
结果：编辑器用户体验良好,大大降低美术/策划人员的学习成本, 提高团队产出效率.
</p>

<p>
2、*与本方案最相近的现有技术
一个基于QT框架实现的UI编辑器.
</p>

<p>
2.1现有技术的技术方案
提供与本立项接近的现有技术以及存在的缺陷，建议以图文结合的方式。
一个使用c++语言基于QT框架进行开发的,功能比较简陋的编辑器.
</p>

<p>
它的主要功能
1)加载整个项目的UI框架
2)查看单个UI界面
3)简单的编辑操作(不支持拖拽)
4)保存编辑结果
</p>

<p>
2.2现有技术的缺点及本技术方案会解决的问题
技术缺点可以是现有技术成本高、误码率高、传输速度慢、安全性差等类似问题，对于个人用户体验不佳等人为感知的因素，应挖掘其背后技术内涵的不足。
现有方案缺陷: 
1)功能不完善, 几乎无法进行基本的添加和删除操作.
2)用户体验差, 甚至不支持拖拽
3)加载和刷新速度慢, 程序经常崩溃
4)学习成本高
</p>

<p>
本方案会解决的问题:
1)完善功能
2)结合 unity自身的特性, 大大提升用户体验
3)大幅提升性能, 降低崩溃率
4)容易学习, 对美术和策划人员友好.
</p>

<p>
3、*本技术方案的详细阐述 
此部分请描述发明方案的详细技术方案，以及如何解决现有技术中的问题，不能只有原理，也不能只做产品操作或者功能的介绍。
落守卫战手游项目UI编辑器截图:
</p>

<p>
本技术方案首先解析UI文件并通过unity绘制出来,为用户呈现一个友好的可交互界面.它允许用户在界面上通过拖拽,缩放,增删等操作进行UI设计,最后把结果输出到UI文件中.
</p>

<p>
1)UI 数据结构
本技术方案的UI数据从上到下划分为3个模块:页面(page),实体(entity),纹理(texture).它们的存在形式是三组独立的xml文件.
每个页面文件对应着一个具体的UI界面.页面文件由一系列组件(component)节点组成,每个节点都对应着UI界面上的一个元素,比如一个按钮,一张图片,一行文字.
组件节点中主要存储UI元素在这个界面中的与排版有关的信息:索引名称,尺寸,对齐方式,锚点,图层和坐标.另外节点还储存一个实体索引,用以在实体文件中定位节点的内容.
</p>

<p>
实体文件中定义一组不同种类的UI元素,为界面中的组件提供外观,以及划分功能.实体文件中可以定义按钮,图片,列表,文字等.
UI元素节点包含的信息可能是元素种类,纹理索引,字号,文字颜色,文字描边,文字内容等.其中纹理索引关联着纹理文件中的一张图片,它决定这个UI元素在UI界面中的外观.
一个实体文件中的元素一般提供给一个或几个相似的页面文件使用,因为一个实体文件被读取到内存后,其中所使用到的纹理也会被全部加载到内存中.
</p>

<p>
纹理文件是一系列纹理元素的集合,每个纹理元素储存一张图片的尺寸,格式,名称.位于同一个纹理文件中的图片在游戏打包后会被合并到一张1024*1024的大纹理上,以提高游戏运行效率.
一般同一个纹理文件中储存几个相似的界面所使用的图片,如果这些图片合并后尺寸超过1024*1024,则需要将它们拆分到不同的纹理文件中.
</p>

<p>
1)UI 数据解析
原始的UI数据储存在xml中, 开发编辑器的第一步就是解决xml文件的读写和序列化.
</p>

<p>
本技术方案首先统计部落守卫战i2d引擎中所使用的所有UI元素xml节点及其属性, 为每种节点实现对应的c#类, 然后使用.Net Framework中的Xml Serialization来实现xml读写操作.
示例代码:
</p>


<p>
2)UI元素绘制和排版
解析后的xml节点需要被绘制在Unity场景中. 本方案采用Unity原生的UI框架UGUI进行绘制, 每一个部落UI元素对应一个UGUI Texture (纹理)元素,
部落UI的排版规则与Unity有些出入, 本方案根据实际需要实现了排版规则转换逻辑.
示例代码:
</p>


<p>
3)UI纹理动态读取
现有的技术方案每次刷新操作都要重新加载游戏中所有纹理, 会导致十几秒卡顿, 效率低下, 体验差.
为了解决上述问题, 本方案采用动态加载技术, 既需要绘制时才把相应纹理加载到内存并缓存下来. 这样用户几乎感受不到卡顿, 提升了效率和体验.
</p>

<p>
4)操作界面
原有技术方案的操作界面设计粗糙, 易用性差.
本方案做出的改善包括:
隐藏美术和策划不需要的部分, 减少视觉干扰
利用Unity场景编辑器, 提供完美的拖拽,缩放等体验. 旧方案中只能笨拙的通过编辑数字实现, 低效,不直观.
新方案:
</p>



<p>
旧方案: 
</p>


<p>
在ui结构预览界面中体现出元素的层级关系
        本方案:
</p>

<p>
旧方案(全部平铺, 没有层级):
</p>


<p>
 提供一些旧方案中没有的快捷操作:
</p>
<ul class="org-ul">
<li>模糊搜索:</li>

<li>快捷添加预设组件</li>

<li>快捷保存</li>
</ul>




<p>
3.1 产品侧
此部分请描述发明方案在产品侧的应用场景、功能特性及操作方式，必要时结合UI界面交互图进行说明，例如，方案应用于哪个/哪类产品中，具有何种功能、如何使用等。
3.2技术侧
此部分请描述发明方案在技术侧的硬件环境、实现逻辑（包括前端和后台），以及对数据的处理流程，必要时提供网络拓扑图、流程图、时序图等进行详细说明；
建议通过图文结合的方式，列出硬件架构图、流程图、时序图等，结合图示对相关装置、流程、时序进行详细说明，重点突出创新要点。
</p>

<p>
4、技术方案所产生的有益效果
有益效果是指交底书的技术方案能带来的技术效果，可以是某一点技术改进带来的技术效果，也可以是技术方案整体带来的技术效果。
   为游戏团队提供了直观, 高效, 易用的UI编辑工具. 策划人员得以快速制作原型, 美术人员得以专心的调整视觉效果, 而不必关心UI数据结构的实现细节, 降低了新人的学习成本. 最终整体提高了团队的开发效率.
5、发散思维，针对3中的技术方案，是否还有其他别的替代方案
此部分内容用于扩展创新方案，扩大专利的保护范围，防止他人绕过本技术方案去实现同样的发明目的；替代方案可以是部分结构、部件、方法步骤的替代，也可以是完整技术方案的替代。
直接编写UI的XML文件.
缺点:学习成本巨大, 几乎只有程序能够完全掌握.
</p>

</div>
</div>]]></description>
      <pubDate>2016-07-29</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/07/31/untitled/</guid>
    </item>
    <item>
      <title>Untitled</title>
      <link>http://tsubasawp.github.io/blog/2016/07/31/untitled/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Untitled</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 备份</a></li>
<li><a href="#orgheadline2">2. 2013</a></li>
<li><a href="#orgheadline13">3. 2015</a>
<ul>
<li><a href="#orgheadline3">3.1. 工程转换</a></li>
<li><a href="#orgheadline6">3.2. 工程配置</a>
<ul>
<li><a href="#orgheadline4">3.2.1. 工程文件</a></li>
<li><a href="#orgheadline5">3.2.2. 路径</a></li>
</ul>
</li>
<li><a href="#orgheadline10">3.3. 编译</a>
<ul>
<li><a href="#orgheadline9">3.3.1. 用新版本的 MSBuild 编译难免会出现一些不兼容的状况</a></li>
</ul>
</li>
<li><a href="#orgheadline11">3.4. Incredibuild</a></li>
<li><a href="#orgheadline12">3.5. Old Labs</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 备份</h2>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> 2013</h2>
<div class="outline-text-2" id="text-2">
<p>
2013 支持 incredibuild,但在进行工程转换的时候出现了 bug:原有的工程文件中含有 xml 字符&amp;quote;,导致工程转换结束以后 vs 会 crash&#x2026;
所以暂时放弃
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">3</span> 2015</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> 工程转换</h3>
<div class="outline-text-3" id="text-3-1">
<p>
直接自动升级工程即可. 升级完毕后可以在 vs2015 中直接打开,工程目录保持不变. 升级之前会自动备份工程.
</p>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.2</span> 工程配置</h3>
<div class="outline-text-3" id="text-3-2">
<p>
vs2013/2015 的工程配置与 vs2008 区别比较大.
</p>
</div>
<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">3.2.1</span> 工程文件</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
diff 了一下转换前后的工程文件,他们格式完全不同,基本不太可能手动修改
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">3.2.2</span> 路径</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
vs2013/2015 的工程路径后不能带`\`,这一点与 2008 不同,需要格外注意
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">3.3</span> 编译</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">3.3.1</span> 用新版本的 MSBuild 编译难免会出现一些不兼容的状况</h4>
<div class="outline-text-4" id="text-3-3-1">
</div><ol class="org-ol"><li><a id="orgheadline7"></a>对命名空间检查更加严格了,编译过程中出现很多"多次定义"error, 解决方案是为其中某一个添加命名空间.<br  /><div class="outline-text-5" id="text-3-3-1-1">
<p>
todo 测试兼容性
</p>
</div></li>
<li><a id="orgheadline8"></a>sprintf 重定义 error<br  /></li></ol>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">3.4</span> Incredibuild</h3>
<div class="outline-text-3" id="text-3-4">
<p>
incredibuild 5.0 不支持 2015&#x2026;&#x2026;.这个太伤了..
好在 incredibuild 7 号称免费版可以用 4 核,也可以凑合用一下 (然而那个鬼官网死活没法下载
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">3.5</span> Old Labs</h3>
<div class="outline-text-3" id="text-3-5">
<p>
千辛万苦终于编译过了。。。纳尼 error LNK2019， 这种不详的预感是怎么回事。。
经过一番 google，产生这个 error 的原因是项目使用的第三方 lib 是由上古版本的 vs 编译而成的，无法兼容。
</p>

<p>
最糟糕的是，这些库里的一部分似乎已经绝版了。。。
</p>

<p>
很遗憾，工程升级之路只能到此为止了。在此记录下整个事件的过程。
</p>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-29</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/07/31/untitled/</guid>
    </item>
    <item>
      <title>Hello World</title>
      <link>http://tsubasawp.github.io/blog/2016/01/16/hello-world/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Hello World</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. First Blog From Org-Page</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> First Blog From Org-Page</h2>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/01/16/hello-world/</guid>
    </item>
    <item>
      <title>PPPUC++ Reading Note</title>
      <link>http://tsubasawp.github.io/blog/2016/01/26/pppuc++-reading-note/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>PPPUC++ Reading Note</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline6">1. CH. 17  Memory, Address</a>
<ul>
<li><a href="#orgheadline1">1.1. 初始化:</a></li>
<li><a href="#orgheadline2">1.2. 空指针:</a></li>
<li><a href="#orgheadline3">1.3. Free-Store:</a></li>
<li><a href="#orgheadline4">1.4. 析构函数:</a></li>
<li><a href="#orgheadline5">1.5. 指针和引用:</a></li>
</ul>
</li>
<li><a href="#orgheadline13">2. CH. 18 Vector and Array</a>
<ul>
<li><a href="#orgheadline7">2.1. Copying</a></li>
<li><a href="#orgheadline8">2.2. Moving</a></li>
<li><a href="#orgheadline9">2.3. explicit</a></li>
<li><a href="#orgheadline10">2.4. Get &amp; Set</a></li>
<li><a href="#orgheadline11">2.5. Array</a></li>
<li><a href="#orgheadline12">2.6. Excrise</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">1</span> CH. 17  Memory, Address</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-c++">int main()
{
  char a = 'a';
  char b = 'b';
  void *pv = &amp;a;
  int *pa = (int*)pv;
  std:: cout &lt;&lt;*pa&lt;&lt;std::endl;
  *pa = 65535;
  std:: cout &lt;&lt;(char*)&amp;a&lt;&lt;" "&lt;&lt;(char*)&amp;b&lt;&lt;std::endl;
  std:: cout &lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;std::endl;
  return 0;
}

�� b��
� b
</pre>
</div>

<p>
实测堆上分配的内存并没有溢出
</p>

<p>
int* 和 char* 不能直接互相赋值的原因: 索引数组时地址跨越长度
</p>
</div>

<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> 初始化:</h3>
<div class="outline-text-3" id="text-1-1">
<p>
为了避免误用未初始化的变量, 尽量保证变量在被声明的同时初始化.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> 空指针:</h3>
<div class="outline-text-3" id="text-1-2">
<p>
c++11 引入了nullptr, 旨在于解决null的二义性问题
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> Free-Store:</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Free-Store由Store Manager管理
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> 析构函数:</h3>
<div class="outline-text-3" id="text-1-4">
<p>
占用Free-Store的类都需要析构函数
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.5</span> 指针和引用:</h3>
<div class="outline-text-3" id="text-1-5">
<p>
传值和传指针: 指针允许nullptr, 可能需要额外写防御代码.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">2</span> CH. 18 Vector and Array</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>initializer<sub>list</sub></li>
<li>copy constructor</li>
<li>copy assignment</li>
</ul>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">2.1</span> Copying</h3>
</div>



<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">2.2</span> Moving</h3>
<div class="outline-text-3" id="text-2-2">
<p>
&amp;&amp; ?
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">2.3</span> explicit</h3>
</div>


<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">2.4</span> Get &amp; Set</h3>
<div class="outline-text-3" id="text-2-4">
<p>
索引靠重载[]运算符实现, 并返回reference. 
</p>
<ul class="org-ul">
<li>若返回值则只能get无法set(可用作const版本), 返回指针则书写起来比较别扭.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">2.5</span> Array</h3>
<div class="outline-text-3" id="text-2-5">
<p>
array的问题: 编译器难以做到边界检查
pointer arithmetic
</p>
</div>
</div>


<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">2.6</span> Excrise</h3>
<div class="outline-text-3" id="text-2-6">
<p>
<i>/
/</i>  main.cpp
<i>/  PPPUC
/</i>
<i>/  Created by Tsubasa on 1/30/16.
/</i>  Copyright (c) 2016 tsu. All rights reserved.
//
</p>

<p>
#include &lt;iostream&gt;
using namespace std;
</p>

<p>
class Vector
{
  int sz;
  double * elem;
public:
  Vector(int s): sz{s}, elem{new double[s]}
  {
    for(int i = 0; i &lt; sz; i++) elem[i] = 0;
  }
</p>

<p>
Vector(initializer<sub>list</sub>&lt;double&gt; lst): sz{(int)lst.size()},elem{new double[lst.size()]}
{
  copy(lst.begin(),lst.end(),elem);
}
</p>

<p>
Vector(const Vector&amp;);
</p>

<p>
Vector&amp; operator=(const Vector&amp;);
</p>

<p>
  ~Vector(){delete[] elem;}
  void Set(int, double);
  void Print();
};
</p>

<p>
void Vector::Set(int index, double value)
{
  if (index &gt;= sz) return;
  elem[index] = value;
}
</p>

<p>
void Vector::Print()
{
  for (int i = 0; i &lt; sz; i++)
    {
      cout&lt;&lt;(elem[i])&lt;&lt;endl;
    }
}
</p>

<p>
Vector::Vector(const Vector&amp; arg)
  :sz(arg.sz),elem(new double[arg.sz])
{
  copy(arg.elem,arg.elem+arg.sz,elem);
}
</p>

<p>
Vector&amp; Vector::operator=(const Vector&amp; arg)
{
  double *d = new double[arg.sz];
  copy(arg.elem,arg.elem+arg.sz,d);
  delete[] elem;
  elem = d;
  sz = arg.sz;
  return *this;
}
</p>

<p>
// exc 1
char <b>strup(const char</b> a)
{
  int sz = 0;
  while ( a[sz] != 0 )  sz++;
</p>

<p>
char * res = new char[sz+1];
for(int i = 0; i &lt;= sz; i++) res[i] = *a+i;
</p>

<p>
  return res;
}
</p>

<p>
// exc 2
</p>


<p>
int main(int argc, const char * argv[]) {
</p>

<p>
  return 0;
}
</p>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/01/26/pppuc++-reading-note/</guid>
    </item>
    <item>
      <title>SICP-CH1-构造过程抽象</title>
      <link>http://tsubasawp.github.io/blog/2016/03/09/sicp-ch1-构造过程抽象/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>SICP-CH1-构造过程抽象</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline79">1. 构造过程抽象</a>
<ul>
<li><a href="#orgheadline8">1.1. 程序设计的基本元素</a>
<ul>
<li><a href="#orgheadline1">1.1.1. 表达式</a></li>
<li><a href="#orgheadline2">1.1.2. 命名和环境</a></li>
<li><a href="#orgheadline3">1.1.3. 组合式求值</a></li>
<li><a href="#orgheadline4">1.1.4. 复合过程</a></li>
<li><a href="#orgheadline5">1.1.5. 过程应用的代换模型</a></li>
<li><a href="#orgheadline6">1.1.6. 条件表达式和谓词</a></li>
<li><a href="#orgheadline7">1.1.7. [习题]</a></li>
</ul>
</li>
<li><a href="#orgheadline10">1.2. 实例:采用牛顿法求平方根</a>
<ul>
<li><a href="#orgheadline9">1.2.1. [习题]</a></li>
</ul>
</li>
<li><a href="#orgheadline13">1.3. 过程作为黑箱抽象</a>
<ul>
<li><a href="#orgheadline11">1.3.1. 局部名</a></li>
<li><a href="#orgheadline12">1.3.2. 内部定义和块结构</a></li>
</ul>
</li>
<li><a href="#orgheadline47">1.4. 过程与它们所产生的计算</a>
<ul>
<li><a href="#orgheadline14">1.4.1. 线性的递归和迭代</a></li>
<li><a href="#orgheadline17">1.4.2. [习题]</a></li>
<li><a href="#orgheadline18">1.4.3. 树形递归</a></li>
<li><a href="#orgheadline22">1.4.4. [习题]</a></li>
<li><a href="#orgheadline23">1.4.5. 增长的阶</a></li>
<li><a href="#orgheadline26">1.4.6. [习题]</a></li>
<li><a href="#orgheadline27">1.4.7. 求幂</a></li>
<li><a href="#orgheadline32">1.4.8. [习题]</a></li>
<li><a href="#orgheadline33">1.4.9. 最大公约数</a></li>
<li><a href="#orgheadline35">1.4.10. [习题]</a></li>
<li><a href="#orgheadline36">1.4.11. 素数检测</a></li>
<li><a href="#orgheadline37">1.4.12. 概率方法</a></li>
<li><a href="#orgheadline46">1.4.13. [习题]</a></li>
</ul>
</li>
<li><a href="#orgheadline78">1.5. 用高阶函数做抽象</a>
<ul>
<li><a href="#orgheadline48">1.5.1. 过程作为参数</a></li>
<li><a href="#orgheadline53">1.5.2. [练习]</a></li>
<li><a href="#orgheadline54">1.5.3. 用lambda构造过程</a></li>
<li><a href="#orgheadline55">1.5.4. 用let创建局部变量</a></li>
<li><a href="#orgheadline57">1.5.5. [习题]</a></li>
<li><a href="#orgheadline60">1.5.6. 过程作为一般性的方法</a></li>
<li><a href="#orgheadline66">1.5.7. [习题]</a></li>
<li><a href="#orgheadline69">1.5.8. 过程作为返回值</a></li>
<li><a href="#orgheadline77">1.5.9. [习题]</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
sicp窝终于回来了&#x2026;
</p>

<p>
[前言]
首先总结一下前言吧. 这本书的目标是教授一种通用的方法学思想, 不仅限于计算机程序设计.
采用scheme(lisp的一种方言)教授这门课,是因为它集powerful与beautiful于一身.
</p>

<p>
ps:第一句话说这本书是MIT计算机科学的入门教材&#x2026;看到这个我就跪下了. 
</p>

<div id="outline-container-orgheadline79" class="outline-2">
<h2 id="orgheadline79"><span class="section-number-2">1</span> 构造过程抽象</h2>
<div class="outline-text-2" id="text-1">
<p>
计算过程: 存在于计算机里的一类抽象事物,这些过程会去操作一些称为 <code>数据</code> 的抽象事物. 人们创建出一些称为 <code>程序</code> 的规则模式, 以指导这类过程的进行.
</p>

<p>
计算过程的lisp描述本身可以作为lisp的数据来表示和操作. 这种灵活性使lisp称为探索语言特征的最方便的语言之一.
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">1.1</span> 程序设计的基本元素</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一个powerful的语言, 除了能够执行任务, 更应该能帮助程序猿组织自己的思想.
</p>

<ul class="org-ul">
<li>基本表达形式</li>
<li>组合的方法</li>
<li>抽象的方法</li>
</ul>

<p>
在程序设计中,我们需要处理两类要素:过程和数据. 本章把重点放在过程上.
</p>
</div>

<div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1"><span class="section-number-4">1.1.1</span> 表达式</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
最简单的表达式: 42, 表示基本过程的表达式: ( + 42 42 ). '+'称为 <code>运算符</code>, 数字是 <code>运算对象</code>, 求值过程就是将运算符所刻画的运算过程应用于运算对象.
</p>

<p>
lisp把运算符放在左边, 称为 <code>前缀表示</code>. 前缀表示的优点是:
</p>
<ul class="org-ul">
<li>可以带有任意个实参而没有歧义</li>
<li>可以直接扩充, 允许出现组合式嵌套, 如(+ ( * 3 5 ) ( - 10 6))</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2"><span class="section-number-4">1.1.2</span> 命名和环境</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
程序设计语言需要提供一种[通过名字去使用计算对象]的方式.
</p>

<p>
在scheme中, 命名通过define来进行.
</p>
<pre class="example">
(define size 2)
</pre>
<p>
我们可以把值2与符号size关联, 又能够提取出这个值, 这说明解释器有存储能力,以维护名字-值对偶的轨迹, 这种存储称为 <code>环境</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4">1.1.3</span> 组合式求值</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
求值一个组合式的步骤是:
</p>
<ul class="org-ul">
<li>1) 求值该组合式的各个子表达式</li>
<li>2) 将作为最左子表达式的值的过程应用于相应的实际参数.</li>
</ul>

<p>
没错就是递归. 递归是一种处理层次结构的强有力的技术. 这种计算过程称为 <code>树形积累</code>.
</p>

<p>
在求值过程中, <code>环境</code> 用于确定表达式中各个符号的意义, 它为求值过程提供了一种上下文.
</p>

<p>
例外: 对表达式 (define x 1) 求值不是把define运用于两个参数, 因为define的作用是关联x和1, 也就是说(define x 1)不是一个组合式. 这种例外称为 <code>特殊形式</code> .
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">1.1.4</span> 复合过程</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
上述的某些元素也会出现在其它语言中:
</p>
<ul class="org-ul">
<li>数和算术运算是基本的数据和过程</li>
<li>组合式的嵌套提供了一种组织起多个操作的方法</li>
<li>定义是一种受限的抽象手段, 它为名字关联响应的值.</li>
</ul>

<p>
下面来讲威力更强大的 <code>过程定义</code>
</p>
<pre class="example">
(define (square x) (* x x ))
</pre>
<p>
上面定义了一个复合过程square, 定义好之后可以这样使用
</p>
<pre class="example">
(square 21)
</pre>
<p>
有点像定义函数. 接下来我们可以把square作为基本构建去定义其它过程
</p>
<pre class="example">
(define (sum-of-squares x y) ( + (square x) (square Y)))
</pre>

<p>
复合过程的使用方式与基本过程完全一致.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">1.1.5</span> 过程应用的代换模型</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
对带有复合过程的组合式求值, 解释器会先"展开"复合过程, 把问题规约为对另一个组合式求值. 
</p>
<pre class="example">
(square 21) -&gt; (* 21 21)
</pre>
<p>
这种计算过程称为过程应用的 <code>代换模型</code>
</p>

<p>
<code>应用序</code>: 先求值参数而后应用的求值模型
</p>

<p>
<code>正则序</code>: 完全展开而后规约的求值模型
</p>

<p>
lisp采用应用序求值, 部分原因在于这样可以避免对于表达式的重复求值, 重点是在超出可以采用替换方式模拟的过程范围之后, 正则序的处理将变得复杂的多.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">1.1.6</span> 条件表达式和谓词</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
    条件表达式
依据不同情况采取不同动作的结构叫做 <code>分情况分析</code>
<code>cond</code>
</p>
<pre class="example">
(cond ((&gt; x 0 )x) ((= x 0) 0) ((&lt; x 0) (-x)))
(cond ((&lt; x 0) (-x) (else x)))
</pre>
<p>
else是一个特殊符号,可以用在cond最后一个位置,如果cond所有分支都被跳过,就会返回else的值
<code>if</code>
</p>
<pre class="example">
(if (&lt; x 0) (-x) x)
</pre>
<p>
if是cond的一种受限形式, 适用于只有两种情况的分析.
谓词: <code>&lt; &gt; and or not</code> &#x2026;
注意and和or都是特殊形式,它们的子表达式不一定求值. not则是一个普通过程.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><span class="section-number-4">1.1.7</span> [习题]</h4>
<div class="outline-text-4" id="text-1-1-7">
<ul class="org-ul">
<li>1.1 .求值(选做一部分)</li>
</ul>
<p>
(define a 3) -&gt; a
(define b ( + a 1)) -&gt; b
(= a b) -&gt; #f
</p>

<ul class="org-ul">
<li>1.2 将下面表达式变换为前缀形式:</li>
</ul>
<p>
(5+4+(2-(3-(6+5/4))))/(3*(6-2)(2-7))
</p>

<pre class="example">
(/ (+ 5 4 (- 2 (- 3 ( + 6 (/ 5 4))))) (* 3 (- 6 2) ( - 2 7)))
</pre>

<ul class="org-ul">
<li>1.3 定义一个过程, 它以三个数为参数, 返回其中较大的两个数之和</li>
</ul>
<pre class="example">
(define (min x y z) 
      (cond (((&lt; x y) and (&lt; x z))  x)
  (((&lt; y x) and (&lt; y z))  y)
  (else z)))
(define (sum2 x y z) (- (+ x y z) (min x y z )))
</pre>

<ul class="org-ul">
<li>1.4 仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型, 根据对这一模型的认知描述下面过程的行为:</li>
</ul>
<pre class="example">
(define (a-plus-abs-b a b) ((if (&gt; b 0)  + -) a b))
</pre>
<ul class="org-ul">
<li>对子表达式(&gt; b 0)求值, 得结果r1</li>
<li>对子表达式(if (r1) + -)求值, 得到结果r2, r2是运算过程.</li>
<li>对(r2 a b)求值</li>

<li>1.5 Ben发明了一种检测方法,能够确定解释器以正则序求值, 还是以应用序求值. 他定义了下面两个过程:</li>
</ul>
<pre class="example">
(define (p) (p))
(define (test x y) (if ( = x 0) 0 y))
(test 0 (p))
</pre>
<p>
用应用序和正则序解释器运行它们, 最终会发生什么?
</p>
<ul class="org-ul">
<li>应用序: 0</li>
<li>正则序: 无限循环. 因为无论(= x 0)的结果如何, y都会被求值.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">1.2</span> 实例:采用牛顿法求平方根</h3>
<div class="outline-text-3" id="text-1-2">
<p>
上面介绍的过程都很像常规数学函数, 然而数学和计算机过程有一些区别:
</p>
<ul class="org-ul">
<li>数学关心说明性的描述(是什么)</li>
<li>计算机关心行动性的描述(怎么做)</li>
</ul>

<p>
一个求平方根的数学描述是: squrt(x) = y, y&gt;=0 &amp;&amp; y<sup>2</sup>=x. 我们无法把它直译成计算机函数.
计算机求平方根的常用方法是:
<code>牛顿逐步逼近法</code> : 先猜测一个值a, 并计算b = x/a, 比较a和b是否足够相似, 如果不满足条件则执行一些操作得到更好的猜测a2, 循环往复直到求出平方根.
</p>

<p>
基本策略:
</p>
<pre class="example">
(define (sqrt-iter guess x)
  (if (good-enough guess x)
      guess
      (sqrt-iter (improve guess x) x)))
</pre>

<p>
填充细节:
</p>
<pre class="example">
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y) (/ (+ x y) 2))

(define (good-enough guess x)
        (&lt; (abs (- (square guess) x)) 0.001))
</pre>

<p>
启动:
</p>
<pre class="example">
(define (squrt x) (sqrt-iter 1.0 x))    
</pre>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">1.2.1</span> [习题]</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>1.6 可否通过cond定义一个常规过程来代替if呢? Eva尝试写了以下程序,</li>
</ul>
<p>
问: 如果用这个new-if来实现求平方根程序sqrt-iter,会有什么问题
</p>
<pre class="example">
(define (new-if predicate then-clause else-clause)
        (cond (predicate then-clause)
              (else else-clause)))
</pre>
<p>
答: 问题在于cond的所有分支都会被求值. 
sqrt-iter是递归,if满足条件时不对else-clause求值, 从而可以停止递归调用.
而new-if由于所有分支都会无条件求值, 所以它应用于递归函数时根本停不下来.
</p>

<ul class="org-ul">
<li>1.7 上面good-enough的实现对于很小或很大的数来说不太好, 请给出证明.</li>
</ul>
<p>
如果使用监测猜测值改变比率的方式, 对于大数或小数来说可以工作吗?
</p>
<ul class="org-ul">
<li>对于小于0.001(good-enough的临界值)的小数,good-enough无法进行正确的判断.</li>
</ul>
<p>
对于大数来说, 由于精度不足以表示guess和x之间的差(good-enough几乎永远为false), 程序陷入死循环.
</p>
<ul class="org-ul">
<li>改变比率的算法对大数和小数都可以工作.</li>
</ul>
<pre class="example">
(define (good-enough old-guess new-guess)
        (&lt; (/ (abs (- old-guess new-guess)) old-guess) 0.01))
</pre>

<ul class="org-ul">
<li>1.8 用牛顿法求立方根</li>
</ul>
<p>
如果y是x立方根的一个近似值,那么下面公式可以给出一个更好的近似值: (x/y<sup>2</sup> +2*y)/3
</p>
<pre class="example">
(define (cube-iter guess x)
  (if (good-enough-cube guess x)
      guess
      (cube-iter (improve-cube guess x) x)))

(define (good-enough-cube guess x)
        (&lt; (abs (- (* guess guess  guess) x)) 0.001))

(define (improve-cube y x)
    (/ (+ (/ x (* y y)) (* 2 y)) 3))

(define (cube x) (cube-iter 1 x))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.3</span> 过程作为黑箱抽象</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<code>过程抽象</code> 一个过程的定义应当能隐藏起一些细节,使得过程的使用者可以直接复用而不必关心实现细节.
</p>
</div>

<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">1.3.1</span> 局部名</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
过程的意义应该不依赖于其作者为形式参数所选定的名字.
</p>

<p>
一个过程的定义 <code>约束</code> 了它所有形式参数,形参的具体名字完全没有关系, 这样的名字称为 <code>约束变量</code> .
相反如果一个变量不是被约束的, 它就是 <code>自由的</code>. 
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">1.3.2</span> 内部定义和块结构</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
平方根程序有个问题, 它由许多分离的过程组成, 而实际用户只关心sqrt这一个过程, 其它过程不必暴露给用户.
(要运行这个程序也很蛋疼啊&#x2026;)
</p>

<p>
所以,我们需要把这些麻烦的子过程局部化, 把它们隐藏到sqrt里面.
</p>

<pre class="example">
(define (sqrt x)
   (define (good-enough ...))
   (define (improve-guess ...))
   (if (good-enough ...) ...)) ;;懒得敲了,自行脑补吧...
</pre>

<p>
这种嵌套的定义称为 <code>块结构</code>. 它是最简单的名字包装问题的一种正确解决方式. (讲道理这话真的是绕&#x2026;
</p>

<p>
另外, 采用这种结构除了可以把辅助过程隐藏之外, 还可以利用 <code>词法作用域</code> 来简化辅助过程的形参.
对这个例子来说,可以省略掉许多x.
</p>

<p>
[小历史] 块结构的思想来自程序设计语言Algol 60.
</p>
</div>
</div>
</div>



<div id="outline-container-orgheadline47" class="outline-3">
<h3 id="orgheadline47"><span class="section-number-3">1.4</span> 过程与它们所产生的计算</h3>
<div class="outline-text-3" id="text-1-4">
<p>
能够看清所考虑的动作的后果的能力, 是非常重要的. 只有在此之后, 人们才能 <code>反向推理</code>
</p>
</div>

<div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14"><span class="section-number-4">1.4.1</span> 线性的递归和迭代</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
两种计算过程:
<code>线性递归过程</code> 在这种计算过程里,代换模型展示出一种先展开后收缩的形状,最大长度正比于n.
解释器为递归过程维护一部分状态信息.递归过程所消耗的内存与n成正比.
注意[递归计算过程]与[递归过程]是两个概念.
<code>迭代计算过程</code> 可以用固定数目的状态描述的计算过程. 与递归不同的是, 迭代计算过程中不会出现增长或收缩.
迭代过程的所有状态信息都保存在程序遍历昂立.迭代过程所消耗的内存是固定的.
</p>

<p>
某些语言(Pascal,C..)对递归过程的解释,消耗的内存总是与n成正比, 即使所描述的计算过程是迭代的.
要描述迭代过程, 必须借助于"循环结构".而scheme则没有这个缺陷.
<code>尾递归</code> 总是能在常量的空间中执行迭代型计算过程.
</p>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">1.4.2</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-2">
</div><ol class="org-ol"><li><a id="orgheadline15"></a>1.9 用代换模型展示下面两个过程在求值(+ 4 5)时所产生的计算过程. 它们是递归或者迭代吗?<br  /><div class="outline-text-5" id="text-1-4-2-1">
<pre class="example">
(define (+ a b) (if (= a 0) b (inc (+ (dec a) b))))
</pre>
<p>
计算过程(纯手打):
</p>
<pre class="example">
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
</pre>
<p>
它是递归计算过程
</p>

<pre class="example">
(define (+ a b) (if (= a 0) b (+ (dec a) (inc b))))
</pre>
<p>
计算过程:
</p>
<pre class="example">
(+ 4 5)
(+ 3 7)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
</pre>
<p>
它是迭代计算过程
</p>
</div></li>

<li><a id="orgheadline16"></a>下面是一个称为ackermann函数的数学函数<br  /><div class="outline-text-5" id="text-1-4-2-2">
<p>
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
  ((= y 1) 2)
  (else (A (- x 1) (A x (- y 1))))))
</p>

<p>
下面各表达式的值是什么(人肉算啊!)
</p>
<ul class="org-ul">
<li>(A 1 10) 1024</li>
<li>(A 2 4) 65536</li>
</ul>
<p>
(a 1 (a 2 3)).. (a 1 (a 1 (a 1 (a 2 1)))),(a 1 (a 1 (a 1 2))),
(a 1 (a 1 (a 0 (a 1 1)))),(a 1(a 1 (* 2 2))),(a 1(a 1 4)),(a 1 16),2<sup>16</sup>
</p>
<ul class="org-ul">
<li>(A 3 3) 65536</li>
</ul>
<p>
(a 2 (a 3 2)),(a 2(a 2(a 3 1))),(a 2 (a 2 2)),(a 2 4),65536
</p>


<p>
下面过程的数学定义是?
</p>
<ul class="org-ul">
<li>(define (f n) (A 0 n)) : f = 2*n</li>
<li>(define (g n) (A 1 n)) : g = 2<sup>n</sup></li>
<li>(define (h n) (A 2 n)) : h = 2^(2<sup>(2&#x2026;)</sup></li>
</ul>
</div></li></ol>
</div>

<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">1.4.3</span> 树形递归</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
另一种常见的例子🌰,比如菲波那切数列.
</p>

<p>
朴素的树形递归:
</p>
<pre class="example">
(define (fib n)
 (cond ((= n 0) 0)
  ((= n 1) 1)
  (else (+ (fib (- n 1)) (fib ( - n 2))))))
</pre>
<p>
优化的迭代版本:
</p>
<pre class="example">
(define (fib-it a b count)
(cond ((= count 0) b)
  (else (fib-it (+ a b) a (- count 1)))))
(define (fib2 n) (fib-it 1 0 n))
</pre>
</div>
</div>


<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">1.4.4</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-4">
</div><ol class="org-ol"><li><a id="orgheadline19"></a>函数f由如下规则定义: 如果n&lt;3, 那么f(n)=n, 如果n&gt;=3, 那么f(n)=f(n-1)+2f(n-1)+3f(n-3).分别实现递归和迭代版本.<br  /><div class="outline-text-5" id="text-1-4-4-1">
<pre class="example">
;;递归
(define (f11 n)
  (cond ((&lt; n 3) n)
  (else (+ (f11 (- n 1))
     (* 2 (f11 (- n 2)))
     (* 3 (f11 (- n 3)))))))
;; 迭代
(define (f11-it a b c n)
  (cond ((&lt; n 3) a)
  (else (f11-it (+ a (* 2 b) (* 3 c)) a b (- n 1)))))
(define (f112 n) (f11-it 2 1 0 n))
</pre>
</div></li>

<li><a id="orgheadline20"></a>写一个过程,采用递归计算出帕斯卡三角形<br  /><div class="outline-text-5" id="text-1-4-4-2">
<pre class="example">
(define (psc n k)
  (cond ((&gt; k n) 0)
      ((= n 0) 1)
  ((= k 0) 1)
  (else (+ (psc (- n 1) (- k 1))  (psc (- n 1) k)))))
</pre>
</div></li>

<li><a id="orgheadline21"></a>1.13<br  /><div class="outline-text-5" id="text-1-4-4-3">
<p>
排版渣表示这道题好不想敲啊&#x2026;按照题目提示用数学归纳法证明等式比较容易,证明接近整数稍微需要一点想象力&#x2026;
</p>

<p>
习题解如下, 各路学霸出没:
<a href="http://sicp.readthedocs.org/en/latest/chp1/13.html">http://sicp.readthedocs.org/en/latest/chp1/13.html</a>
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23"><span class="section-number-4">1.4.5</span> 增长的阶</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
<code>增长的阶</code> 用以描述计算过程消耗计算资源的速率.
</p>
<ul class="org-ul">
<li>O(n): 规模增加一倍, 资源增加一倍</li>
<li>O(n<sup>2</sup>): 规模增加1, 资源增加常数倍. 比如树形递归占用空间是(ϕ<sup>n</sup>)</li>
<li>O(lg n):规模增加一倍, 资源增加一个常数.</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">1.4.6</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-6">
</div><ol class="org-ol"><li><a id="orgheadline24"></a>1.14 画出1.2.2节过程(count-change 11)的计算过程. 当现金量增加时,这一过程空间和步数增长的阶各是什么?<br  /><div class="outline-text-5" id="text-1-4-6-1">
<p>
计算过程在纸上画了一遍&#x2026;懒得搬上来了, 直接参考习题解里的图吧
后面两个估算没有找到标准答案,先把自己的思路写在这里.
</p>

<p>
设现金量为n,币种数为m,则
</p>
<ul class="org-ul">
<li>步数增长的阶:</li>
</ul>
<p>
这个计算过程受到币种限制, 所以不能简单的用二叉树复杂度来估算.
根据计算过程cc, 当n比较小时(比如小于50), 复杂度为O(n).
当n比较大的时候, 复杂度正比于n能够被最大币种(这里是50)整除的次数.
o(f(n))=(1+2+3+&#x2026;n/50)*n = ((1+n/50)*(n/50)/2)*n = o(n<sup>2</sup>).
</p>

<ul class="org-ul">
<li>空间增长的阶: O(n+m).树的最大深度由n决定, 最深子树总是全部由1元钱凑成n的情况.</li>
</ul>
</div></li>

<li><a id="orgheadline25"></a>1.15 题目略.<br  /><div class="outline-text-5" id="text-1-4-6-2">
<p>
[吐槽:原来可以这样实现sin,长姿势了]
</p>

<p>
如果解释器的代换模型是是 <code>应用序</code> ,则这个问题是线性迭代:
</p>
<ul class="org-ul">
<li>p将被使用多少次?  5次.</li>
<li>空间增长的阶: n/(3<sup>k</sup>) = 0.1, k=log<sub>3</sub> (10*n), 所以是O(lg n)</li>
<li>步数增长的阶: O(lg n)</li>
</ul>
<p>
如果解释器是 <code>正则序</code> ,则这个问题是树形迭代:
</p>
<ul class="org-ul">
<li>p将被使用多少次?  1 + 4 + 4<sup>2</sup> + 4<sup>3</sup> + 4<sup>4</sup></li>
<li>增长的阶: O(4<sup>n</sup>)</li>
</ul>
</div></li></ol>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">1.4.7</span> 求幂</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
快速求幂法fast-expt:
</p>
<pre class="example">
b^n = (b^(n/2))^2 ;;若n是偶数
b^n = b * b^(n-1) ;;若n是奇数
</pre>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">1.4.8</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-8">
</div><ol class="org-ol"><li><a id="orgheadline28"></a>1.16 用fast-expt的思路定义一个过程, 它按照迭代的方式产生出求幂的计算过程.<br  /><div class="outline-text-5" id="text-1-4-8-1">
<pre class="example">
(define (expt-iter b n a)
  (cond ((= n 0) a)
  ((even? n) (expt-iter  (* b b)  (/ n 2)  a))
  (else (expt-iter  b (- n 1) (* b a)))))
</pre>
</div></li>

<li><a id="orgheadline29"></a>1.17 用fast-expt的思路实现一个反复使用加法计算乘积的过程.<br  /><div class="outline-text-5" id="text-1-4-8-2">
<pre class="example">
(define (fast-mul a n)
  (cond ((= n 0) 0)
  ((= n 1) a)
  ((even? n) (fast-mul (+ a a) (/ n 2)))
  (else (+ a (fast-mul a (- n 1))))))
</pre>
</div></li>

<li><a id="orgheadline30"></a>1.18 求两个整数的乘积<br  /><div class="outline-text-5" id="text-1-4-8-3">
<pre class="example">
(define (mul-iter b n a)
  (cond ((= n 0) a)
  ((even? n) (mul-iter (+ b b) (/ n 2) a))
  (else (mul-iter b (- n 1) (+ a b)))))
</pre>
</div></li>


<li><a id="orgheadline31"></a>1.19 用对数步数计算菲波那切数列<br  /><div class="outline-text-5" id="text-1-4-8-4">
<p>
这道题目是前面求幂过程的推广. 
</p>

<pre class="example">
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
  ((even? count)
   (fib-iter a
       b
       (+ (* p p) (* q q))
       (+ (* 2 p q) (* q q))
       (/ count 2)))
   (else (fib-iter (+ (* b q) (* a q) (* a p))
       (+ (* b p) (* a q))
       p
       q
       (- count 1)))))
</pre>
</div></li></ol>
</div>

<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">1.4.9</span> 最大公约数</h4>
<div class="outline-text-4" id="text-1-4-9">
<p>
GCD(a,b)=GCD(b,r), r是a除以b的余数.
</p>
<pre class="example">
(define (gcd a b)
  (cond ((= b 0) a)
  (else (gcd b (remainder a b)))))
</pre>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35"><span class="section-number-4">1.4.10</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-10">
</div><ol class="org-ol"><li><a id="orgheadline34"></a>1.20 解释器是应用序和正则序时,上述算法求(206 40)的计算过程分别是怎样的,remander分别调用多少次<br  /><div class="outline-text-5" id="text-1-4-10-1">
<ul class="org-ul">
<li>应用序</li>
</ul>
<pre class="example">
(gcd 206 40)
(gcd 40 6)
(gcd 6 4)
(gcd 4 2)
(gcd 2 0)
2
</pre>
<p>
一共4次remander
</p>

<ul class="org-ul">
<li>正则序</li>
</ul>
<pre class="example">
(gcd 206 40)
cond ...
(gcd 40 (re 206 40)) ;;b=6
cond ...  ;; +1
(gcd (re 206 40) (re 40 (re 206 40))) ;;b=4
cond ...  ;; +2
(gcd (re 40 (re 206 40)) (re (re 206 40) (re 40 (re 206 40)))) ;;b=2
cond ...  ;; +4
(gcd .......) ;; b=0
cond ...  ;; + 7
a = (re (re 206 40) (re 40 (re 206 40) = (re 6 4) = 2 ;; +4
</pre>
<p>
一共18次remander
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36"><span class="section-number-4">1.4.11</span> 素数检测</h4>
<div class="outline-text-4" id="text-1-4-11">
<p>
(终于学会打公式了○|￣|_)
</p>

<p>
本节描述两种检查整数n是否为素数的方法,第一个具有O(\(\sqrt{n}\))的增长阶,
第二个具有O(log n)的增长阶.
</p>

<ul class="org-ul">
<li>寻找因子:用从2开始的连续整数开始依次检查它们是否能整除n.如果n不是素数,必然有小于或等于 \(\sqrt{n}\) 的因子,由此可知这个算法拥有O(\(\sqrt{n}\))的增长阶.</li>
<li>费马检查:O(log n)的检查基于数论中著名的费马小定理(数论全忘光了&#x2026;桑不起)</li>
</ul>

<p>
<code>费马小定理</code>: 如果n是一个素数,a是小于n的任意正整数,那么a的n次方与a模n同余.
而如果= 不是素数 =,则大部分a&lt;n都将满足上面的关系,这就引出了检查素数的算法: 如果发现不满足关系的a那么n肯定不是素数.
</p>

<p>
<code>费马检查</code>: 采用许多随机的a来检查,通过的检查越多则n是素数的概率越大.
</p>

<p>
首先定义一个O(log n)的迭代过程计算 \(a^n\) 对m取模的结果(a&lt;n,a&lt;m)
</p>
<pre class="example">
(define (expmod bas exp m)
  (cond ((= exp 0 ) 1)
  ((even? exp)
   (remainder (square (expmod bas (/ exp 2) m)) m))
  (else
   ;;  $(a*a^{n/2}*a^{n/2})%n = (a%n)*(a^{n/2}%n)^2 = a*(a^{n/2}%n)^2
   (remainder (* bas (expmod bas (- exp 1) m)) m))))
</pre>

<p>
其中关于连续求平方的推导如下:
</p>

<p>
\(\gcd((a^{n/2}a^{n/2}),n)=\gcd(a^{n/2},n)\gcd(a^{n/2},n)=\gcd(a^{n/2},n)^2\)
</p>

<p>
\(\gcd((a*a^{n/2}a^{n/2}),n)=\gcd(a,n)\gcd(a^{n/2},n)^2=a*\gcd(a^{n/2},n)\)
</p>

<p>
然后随机1和n-1之间的整数进行测试:
</p>
<pre class="example">
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
  ((fermat-test n) (fast-prime? n (- times 1)))
  (else false)))
</pre>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-4">
<h4 id="orgheadline37"><span class="section-number-4">1.4.12</span> 概率方法</h4>
<div class="outline-text-4" id="text-1-4-12">
<p>
费马检查的结果只有概率上的正确性..但能够证明存在使出错概率任意小的算法.
</p>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46"><span class="section-number-4">1.4.13</span> [习题]</h4>
<div class="outline-text-4" id="text-1-4-13">
</div><ol class="org-ol"><li><a id="orgheadline38"></a>使用smallest-divisor过程找出下面各数的最小因子:199,1999,19999<br  /><div class="outline-text-5" id="text-1-4-13-1">
<p>
首先设计了一个(有点挫)的算法,从2到n遍历,寻找第一个能够整除n的素数.(能够想到的优化版算法只有素数表了orz.
</p>
<pre class="example">
(define (divisor-test a n)
  (cond ((= n 1) 1)
  ((= n 0) 0)
  ((and (fast-prime? a 10) (= (remainder n a) 0)) a)
  (else (divisor-test (+ a 1) n))))

(define (smallest-divisor n) (divisor-test 2 n))计算结果是199:199,1999:1999,19999:7.
</pre>
</div></li>

<li><a id="orgheadline39"></a>观察查找素数的时间.题目略&#x2026;<br  /><div class="outline-text-5" id="text-1-4-13-2">
<pre class="example">
(define (search-for-prime n)
  (cond ((prime? n) 
  (display n))
  (else (cond ((even? n)
         (search-for-prime (+ n 1)))
        (else 
         (search-for-prime (+ n 2)))))))

(define (start-search-prime n start-time)
  (search-for-prime n)
  (newline)
  (display (- (real-time-clock) start-time)))

(define (time-for-search-prime n)
  (start-search-prime n (real-time-clock)))
</pre>
<p>
一开始使用题目给的(runtime)计算时钟周期,结果无论后面加多少个零,结果几乎都在1e-2左右.
后来得知现在的MIT-scheme的runtime按秒计时,换成以tick计时的real-time-clock就对了.
</p>

<p>
测试结果是:
</p>
<ul class="org-ul">
<li>1000:1 (结果是1009,6次测试,平均0.17ms每次)</li>
<li>10000:1 (5,0.25)</li>
<li>100000:1 (3,0.33)</li>
<li>1000000:2 (3,0.67)</li>
<li>10000000:8 (10,0.8)</li>
<li>100000000:15 (5,3)</li>
<li>1000000000:37 (5,7.4)</li>
<li>10000000000:169 (10,16.9)</li>
</ul>
<p>
1000000以下的测试结果差别很小, 1000000以上差异是2.x倍, 可见测试结果与预期的$/sqrt{n}$不符.
</p>
</div></li>

<li><a id="orgheadline40"></a>修改本节开始的smallest-divisor过程,使其步数减半,并检验结果是否符合预期<br  /><div class="outline-text-5" id="text-1-4-13-3">
<pre class="example">
(define (smallest-divisor-fast n)
  (let  ((t (real-time-clock)))
    (display (find-divisor-fast n 2))
    (- (real-time-clock) t)))

(define (find-divisor-fast n test)
  (cond ((&gt; (square test) n) n)
  ((divides? n test) test)
  (else (find-divisor-fast n (next test)))))

(define (next n)
  (cond ((even? n) (+ n 1))
  (else (+ n 2))))
</pre>

<p>
为了使差别比较显著,挑选2个相差10倍左右的素数进行测试:1009,10009
</p>
<ul class="org-ul">
<li>(smallest-divisor-fast (* 1009 10009))  ==&gt; 1</li>
<li>(smallest-divisor (* 1009 10009))       ==&gt; 2</li>
<li>(smallest-divisor-fast (* 10009 10009)) ==&gt; 9</li>
<li>(smallest-divisor (* 10009 10009))      ==&gt; 14</li>
<li>(smallest-divisor-fast (* 20029 20029)) ==&gt; 16</li>
<li>(smallest-divisor-sqre (* 20029 20029)) ==&gt; 26</li>
</ul>
<p>
可见fast版本速度比原有版本快,但两个算法速度比值比2小.
</p>

<p>
初步推测,当算法复杂度低且参数比较小时,这个算法本身的耗时在一个过程的执行过程中占比非常低.
而执行过程所需的大量递归调用,变量绑定等操作消耗掉绝大部分CPU资源,导致我们得到的结果不准确.
而当参数增大时,算法本身占用的资源比例变大,使得结果与我们的预测越来越接近.
</p>

<p>
所以估算算法复杂度并不能完全预测过程的实际执行时间.
</p>
</div></li>

<li><a id="orgheadline41"></a>使用fast-prime?代替prime?实现第二题.并检验结果是否符合预期.<br  /><div class="outline-text-5" id="text-1-4-13-4">
<p>
把上上道题目代码中的prime?换成fast-prime就可以了.
</p>
<pre class="example">
(define (search-for-prime n)
  (cond ((fast-prime? n 50) 
  (display n))
  (else 
   (cond ((even? n)
    (search-for-prime (+ n 1)))
         (else 
    (search-for-prime (+ n 2)))))))
</pre>
<p>
测试结果:
</p>
<ul class="org-ul">
<li>1000:2</li>
<li>10000:2</li>
<li>100000:3</li>
<li>10000000:4</li>
<li>1000000000000:8</li>
</ul>
<p>
差距比预期小的多,但参数越大差别越明显.解释见上一题.
</p>

<p>
[Mark] 学习完后面的内容可能会在解释器层面上对这个问题有新的见解,到时候再补充吧.
</p>
</div></li>

<li><a id="orgheadline42"></a>分析Alyssa的方法是否实用<br  /><div class="outline-text-5" id="text-1-4-13-5">
<p>
Alyssa的方法理论上比本节的算法步数只有1步,但容易溢出.
本节的方法虽然步数多了一些, 但它不会真正进行巨大的乘幂运算, 所以本节的方法更加实用.
</p>
</div></li>

<li><a id="orgheadline43"></a>分析fast-prime?中的expmod使用显示乘法为何会把O(log n)的算法变成O(n)的.<br  /><div class="outline-text-5" id="text-1-4-13-6">
<p>
下面把(expmod base (/ exp 2) m)简写为 <code>ep(n)</code>
</p>

<p>
使用乘法:
</p>
<pre class="example">
ep(n)
(* ep(n/2) ep(n/2))
(* (* ep(n/4) ep(n/4)) (* ep(n/4) ep(n/4)))
(* (* (* ep(n/8) ep(n/8)) (* ep(n/8) ep(n/8))) (* (* ep(n/8) ep(n/8)) (* ep(n/8) ep(n/8))))
...
</pre>
<p>
展开后可得进行expmod运算的次数是 \(2^{log_2{n}}=n\) 次
</p>

<p>
使用square:
</p>
<pre class="example">
ep(n)
(square ep(n/2))
(square (square ep(n/4)))
...
</pre>
<p>
\(log_2{n}\) 次
</p>
</div></li>

<li><a id="orgheadline44"></a>证明注脚47中列出的Carmichael数确实能骗过费马检查.<br  /><div class="outline-text-5" id="text-1-4-13-7">
<p>
首先写一个过程,检验 <b>所有</b> 小于n的a,看 \(a^{n}\) 是否与a模n同余.
</p>
<pre class="example">
(check-prime? 561) =&gt; #t
(check-prime? 1105) =&gt; #t
(check-prime? 1729) =&gt; #t
(check-prime? 2465) =&gt; #t
(check-prime? 2821) =&gt; #t
(check-prime? 6601) =&gt; #t
</pre>
</div></li>

<li><a id="orgheadline45"></a>Miller-Rabin检查<br  /><div class="outline-text-5" id="text-1-4-13-8">
<p>
把前面fast-prime过程中的fermat-test替换为miller-test
</p>
<pre class="example">
(define (miller-test n)
  (define (try-it a)
    (= (expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= n 1) true)
  ((= times 0) true)
  ((miller-test n) (fast-prime? n (- times 1)))
  (else false)))
</pre>
<p>
使用前面的carmichael数测试,结果都为#f
</p>
</div></li></ol>
</div>
</div>

<div id="outline-container-orgheadline78" class="outline-3">
<h3 id="orgheadline78"><span class="section-number-3">1.5</span> 用高阶函数做抽象</h3>
<div class="outline-text-3" id="text-1-5">
<p>
在作用上,过程也是一类抽象,它们描述了一些对于数的复合操作,但不依赖特定的数,甚至不只用数作为参数.
</p>

<p>
<code>高阶过程</code> 是能操作过程的过程, 它能以过程作为参数,或者以过程作为返回值.
</p>

<p>
这也是lisp的一个厉害之处.
</p>
</div>

<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">1.5.1</span> 过程作为参数</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
教材🌰:
</p>
<pre class="example">
(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a) (sum term (next a) next b))))

(define (cub n) (* n n n))
(define (add n) (+ n 1))
(define (sum-cube a b) (sum cub a add b))
</pre>
<p>
使用其它高级语言实现这种过程作为参数的过程时,绝对不会这么简洁.
</p>
</div>
</div>

<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">1.5.2</span> [练习]</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><ol class="org-ol"><li><a id="orgheadline49"></a>上面的sum过程产生一个线性递归, 使用迭代方式重写该过程.<br  /><div class="outline-text-5" id="text-1-5-2-1">
<pre class="example">
(define (sum term a next b)
  (define (iter n result)
    (if (&gt; n b) 
  result
  (iter (next n) (+ result (term n)))))
  (iter a 0))
</pre>
</div></li>

<li><a id="orgheadline50"></a>写一个product过程,返回在给定范围中各点的某个函数值得乘积.请说明如何用product定义faactorial.<br  /><div class="outline-text-5" id="text-1-5-2-2">
<pre class="example">
;; 递归
(define (product a b term)
 (if (&gt; a b)
       1
       (* (term a) (product (+ a 1) b term))))

;; 迭代
(define (product-iter a b next)
  (define (iter n result)
    (if (&gt; n b) 
  result
  (iter (+ n 1) (* result (term n)))))
  (iter a 0))

;; 分子
(define (term-numer a)
  (cond ((odd? a) (+ a 1))
  (else (+ a 2))))
;; 分母
(define (term-deno a)
  (cond ((even? a) (+ a 1))
  (else (+ a 2))))

;; pi/4
(define (quarter-pi n)
  (/ (product 1 n term-numer) (product 1 n term-deno)))
</pre>
</div></li>

<li><a id="orgheadline51"></a>请说明sum和product都是称为accumulate的更一般概念的特殊情况.使用accumulate定义出sum和product.<br  /><div class="outline-text-5" id="text-1-5-2-3">
<pre class="example">
(define (accumulate combinder null-value term a next b)
  (if (&gt; a b) null-value
      (combinder (term a) (accumulate combinder null-value term (next a) next b))))

(define (sum a b) (accumulate + 0 (lambda (a) a) 1 (lambda (a) (+ a 1)) 10))
(define (product a b) (accumulate * 1 (lambda (a) a) 1 (lambda (a) (+ a 1)) 10))
</pre>
</div></li>

<li><a id="orgheadline52"></a>实现filtered-accumulate<br  /><div class="outline-text-5" id="text-1-5-2-4">
<pre class="example">
(define (filtered-accumulate filter combinder null-value term a next b)
  (cond ((&gt; a b) null-value)
  ((filter a) 
   (combinder (term a) 
        (filtered-accumulate filter combinder null-value term (next a) next b)))
  (else 
   (combinder null-value
   (filtered-accumulate filter combinder null-value term (next a) next b)))))
</pre>
</div></li></ol>
</div>

<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54"><span class="section-number-4">1.5.3</span> 用lambda构造过程</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
为了省去单独定义一些简单函数的麻烦,引入lambda特殊形式来完成这类描述,而不必给每个过程绑定名字.
</p>
<pre class="example">
(lambda (x) (+ x 4))
</pre>
<p>
实际上, (define (&lt;name&gt; &lt;param &#x2026;&gt;) ()) 是lambda的一种语法糖.
</p>
<pre class="example">
(define (plus4 n) (+ n 4))
</pre>
<p>
等价于:
</p>
<pre class="example">
(define plus4 (lambda (n) (+ n 4)))
</pre>
<p>
lambda表达式可以用做 <b>组合式的运算符</b>:
</p>
<pre class="example">
((lambda (x) (+ x 4)) 1)
</pre>
</div>
</div>

<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55"><span class="section-number-4">1.5.4</span> 用let创建局部变量</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
lambda的另一个作用是创建局部变量,为此语言里有一个语法糖 <code>let</code>
</p>
<pre class="example">
(define (f x y)
 ((lambda (a b)
  (+ (* x (square a))
    (* y b)
    (* a b)))
  (+ 1 (x y))
  (- 1 y)))
</pre>
<p>
用let形式可以简化为
</p>
<pre class="example">
(define (f x y)
 (let ((a (+ 1 (x y)))
       (b (- 1 y)))
   (+ (* x (square a))
      (* y b)
      (* a b))))
</pre>
<p>
注意使用let约束的局部变量必须在let的body中.
</p>
<ul class="org-ul">
<li>let使人能在尽可能接近其使用的地方建立局部变量约束.</li>
<li>变量的值是在let之外计算的. 如下面过程</li>
</ul>
<pre class="example">
....
(let (x 3)
     (y x))
</pre>
<p>
如果x在let之前的值是2,在let内x=3, 而y=2.
</p>

<p>
有时在过程内部define也有与let一样的效果:
</p>
<pre class="example">
(define (f x y)
  (define a (...))
  (define b (...))
  (+ a b))
</pre>
</div>
</div>

<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">1.5.5</span> [习题]</h4>
<div class="outline-text-4" id="text-1-5-5">
</div><ol class="org-ol"><li><a id="orgheadline56"></a>执行(f f)会发生什么<br  /><div class="outline-text-5" id="text-1-5-5-1">
<p>
(f f)-&gt;(f 2)-&gt;(2 2). 而2不是一个可以应用的过程, 会报错.
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60"><span class="section-number-4">1.5.6</span> 过程作为一般性的方法</h4>
<div class="outline-text-4" id="text-1-5-6">
</div><ol class="org-ol"><li><a id="orgheadline58"></a>通过区间折半法寻找方程的根<br  /><div class="outline-text-5" id="text-1-5-6-1">
<p>
代码略&#x2026;
</p>
</div></li>

<li><a id="orgheadline59"></a>找出函数的不动点<br  /><div class="outline-text-5" id="text-1-5-6-2">
<p>
数x称为函数f的不动点,如果x满足方程 \(f(x)=x\) . 
</p>
<pre class="example">
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
    next
    (try next)))) ;; 这里需要保证收敛
  (try first-guess))
</pre>
</div></li></ol>
</div>

<div id="outline-container-orgheadline66" class="outline-4">
<h4 id="orgheadline66"><span class="section-number-4">1.5.7</span> [习题]</h4>
<div class="outline-text-4" id="text-1-5-7">
</div><ol class="org-ol"><li><a id="orgheadline61"></a>使用fixed-point找出黄金分割 \(phi\) 的值: x-&gt;1+1/x.<br  /><div class="outline-text-5" id="text-1-5-7-1">
<pre class="example">
(fixed-point (lambda (x) (+ 1 (/ 1 x)))  1.0)
</pre>
<p>
x=1.6180327868852458
</p>
</div></li>

<li><a id="orgheadline62"></a>修改fixed-point,使他打印出计算过程.确定x<sup>x</sup>=1000的一个根,并比较采用平均阻尼和不用平均阻尼的计算步骤.<br  /><div class="outline-text-5" id="text-1-5-7-2">
<p>
不用平均阻尼
</p>
<pre class="example">
(fixed-point-log  (lambda (x)  (/ (log 1000) (log x))) 2)
</pre>
<p>
33步
</p>

<p>
使用平均阻尼:
</p>
<pre class="example">
(define (average n) (/ n 2))
(fixed-point-log  (lambda (x) (average (+ x (/ (log 1000) (log x))))) 2)
</pre>
<p>
8步
</p>
</div></li>

<li><a id="orgheadline63"></a>一个无穷连分式是一个如下形式的表达式:<br  /><div class="outline-text-5" id="text-1-5-7-3">
<p>
\(\Large x=\frac{N_1}{D1 + \frac{N_2}{D2 + \frac{N_3}{D_3+...}}}\)
证明当Di和Ni都等于1时,这一连分式产生出\(1/\phi\)
</p>
<pre class="example">
;; 递归
(define (cont-frac n d k it)
  (cond ((= it k) 0)
  (else (/ (n it) (+ (d it) (cont-frac n d k (+ it 1)))))))

(define (gold k)
    (+ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) k 0)))

(gold 11)

;; 迭代
(define (cont-frac-it n d k result)
  (cond ((= k -1) result)
  (else (cont-frac-it n d (- k 1) (/ (n k) (+ (d k) result))))))

(define (gold k)
    (+ 1 (cont-frac-it (lambda (i) 1.0) (lambda (i) 1.0) k 0)))

(gold 11)
</pre>
<p>
k取6时结果具有4位精度, 但不够准确.k越大时,结果越逼近 \(1/\phi\), k取12时,小数点后4位的结果是准确的.
</p>
</div></li>

<li><a id="orgheadline64"></a>使用上一题的cont-frac过程基于欧拉展开式求e的近似值.<br  /><div class="outline-text-5" id="text-1-5-7-4">
<pre class="example">
(define (ora i)
    (cond ((= 0 (remainder (- i 1) 3))
     (* 2 (/ (+ i 2) 3)))
    (else 1.0)))

(define (de-frac k)
  (cont-frac-it
  (lambda (i) 1.0)
  ora
  k
  0))

(define (e k)
  (+ 2 (de-frac k)))
</pre>
</div></li>

<li><a id="orgheadline65"></a>定义过程(tan-cf x k),基于Lambert公式计算正切函数的近似值.<br  /><div class="outline-text-5" id="text-1-5-7-5">
<pre class="example">
(define (tan-cf x k)
  (define (N-tan i) 
    (if (= i 1)
  x
  (- (square x))))
  (define (D-tan i) (- (* 2 i) 1))
  (cont-frac N-tan D-tan k 1))

(tan-cf 1.0 10)
(tan 1)
</pre>
</div></li></ol>
</div>





<div id="outline-container-orgheadline69" class="outline-4">
<h4 id="orgheadline69"><span class="section-number-4">1.5.8</span> 过程作为返回值</h4>
<div class="outline-text-4" id="text-1-5-8">
<p>
把前面所说的平均阻尼概念再抽象一下..
</p>
<pre class="example">
(define (average-damp f)
  (lambda (x) (average x (f x))))

((average-damp square) 10)
</pre>
<p>
这样前面求平方根的过程可改写成:
</p>
<pre class="example">
(define (squrt x)
  (fixed-point (average-damp (lambda (a) (/ x a))) 1.0))
</pre>
<p>
所以现在上面这两行代码中结合了三种思想: 不动点搜寻,平均阻尼,和函数y-&gt;x/y.
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline67"></a>牛顿法<br  /><div class="outline-text-5" id="text-1-5-8-1">
<p>
首先需要有一个方法描述导数
</p>

<p>
\(Dg(x)=\frac{g(x+dx)-g(x)}{dx}\)
这时就能看到将过程作为返回值的威力了:生成导数函数.
</p>
<pre class="example">
(define dx 0.00001) ;; 首先定义一个delta
(define (drive g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
;; test: $D(x^3)=3*x^2$
((drive (lambda (x) (* x x x))) 2)
</pre>

<p>
然后把牛顿法描述为一个求不动点的过程:
</p>
<pre class="example">
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((driv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g ) guess))
(define (squr x)
  (newtons-method (lambda (y) (- (square y) x)) 1.0))
</pre>
</div></li>
<li><a id="orgheadline68"></a>抽象和第一级过程<br  /><div class="outline-text-5" id="text-1-5-8-2">
<p>
计算机程序总会对计算元素的可能使用方式加上某些限制.带有最少限制的元素被称为 <code>第一级状态</code>
第一级元素的某些"特权"包括:
</p>
<ul class="org-ul">
<li>可以使用变量名</li>
<li>可以提供给过程作为参数</li>
<li>可以由过程作为结果返回</li>
<li>可以包含在数据结构中</li>
</ul>
<p>
List给了 <b>过程</b> 完全第一级状态, 这是非常牛逼的(主要是难以实现).
我日常用的几种语言没有谁能做到这些orz
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline77" class="outline-4">
<h4 id="orgheadline77"><span class="section-number-4">1.5.9</span> [习题]</h4>
<div class="outline-text-4" id="text-1-5-9">
</div><ol class="org-ol"><li><a id="orgheadline70"></a>请定义一个过程cubic,它和newtons-method一起使用在下面的表达式里,逼近三次方程x<sup>3</sup>+aX<sup>2</sup>+c的零点<br  /><div class="outline-text-5" id="text-1-5-9-1">
<p>
(newtons-method (cubic a b c) 1)
</p>
<pre class="example">
(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))
;; test
(newtons-method (cubic 3 1 1) 1)
</pre>
</div></li>

<li><a id="orgheadline71"></a>请定义一个过程double,它以一个有一个参数的过程作为参数,double返回一个参数.这一过程将原来那个参数过程应用两次.<br  /><div class="outline-text-5" id="text-1-5-9-2">
<pre class="example">
(define (double f)
  (lambda (x) (f (f x))))
;; test
((double (lambda (x) (square x))) 2)
</pre>
<p>
表达式(((double (double double)) inc ) 5)返回21:
</p>
<pre class="example">
(((double (double double) inc) -&gt; (double (double (double (double inc)))) = 2^4 = 16
</pre>
</div></li>

<li><a id="orgheadline72"></a>定义compose实现复合函数<br  /><div class="outline-text-5" id="text-1-5-9-3">
<pre class="example">
(define (compose f g)
  (lambda (x) (f (g x))))
((compose square inc) 6)
</pre>
</div></li>

<li><a id="orgheadline73"></a>构造f的n次重复应用过程<br  /><div class="outline-text-5" id="text-1-5-9-4">
<pre class="example">
(define (repeated f k)
  (define (it g k n)
    (if (= n (- k 1)) 
  (lambda (x) (g x))
  (it (lambda (x) (f (g x))) k (+ n 1))))
  (it f k 0))

((repeated square 2) 5)
; Value: 625
</pre>
</div></li>

<li><a id="orgheadline74"></a>实现平滑函数<br  /><div class="outline-text-5" id="text-1-5-9-5">
<pre class="example">
(define (smooth f)
  (lambda (x) 
    (/ (+ (f x) (f (- x dx)) (f (+ x dx))) 3)))

(define (smooth-k f k)
  ((repeated smooth k) f))
</pre>
</div></li>

<li><a id="orgheadline75"></a>试验求$x/y<sup>n-1</sup>$需要多少次平均阻尼<br  /><div class="outline-text-5" id="text-1-5-9-6">
<pre class="example">
;;前面定义的求幂过程expt-iter
(define (expt-iter b n a)
  (cond ((= n 0) a)
  ((even? n) (expt-iter  (* b b)  (/ n 2)  a))
  (else (expt-iter  b (- n 1) (* b a)))))
;;定义过程x-&gt;x/y^n
(define (root n x)
  (lambda (y) (/ x (expt-iter y n 1))))
;;应用k次阻尼
(define (repeated-damp f k)
  ((repeated average-damp k) f))

(define (squrt-n n x damp-cnt)
  (fixed-point-log (repeated-damp (root n x) damp-cnt) 1))
</pre>

<p>
试验下来大约至少需要$log{n}$次平均阻尼.
</p>
</div></li>

<li><a id="orgheadline76"></a>写一个过程interative-improve, 它以两个过程为参数. 其中之一用于判定结果是否足够好,另外一个用于猜测更好的结果.<br  /><div class="outline-text-5" id="text-1-5-9-7">
<pre class="example">
(define (iterative-improve good-enough? f)
  (lambda (x)
    (define (try guess)
      (let ((next (f guess)))
  (if (good-enough? guess next)
      next
      (try next))))
    (try x)))
;;定义good-enough?
(define (close-enough? v1 v2)
  (&lt; (abs (- v1 v2)) tolerance))

(define (fixed-point f guess)
  ((iterative-improve close-enough? f) guess))

(define (sqrt n guess)
    ((iterative-improve 
      close-enough? (lambda (x) (/ (+ x (/ n x)) 2))) guess))
</pre>


<p>
以上.
</p>

<p>
(几乎一个月过去了/(ㄒoㄒ)/~~)
</p>
</div></li></ol>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/03/09/sicp-ch1-构造过程抽象/</guid>
    </item>
    <item>
      <title>SICP-CH2-构造数据抽象</title>
      <link>http://tsubasawp.github.io/blog/2016/04/05/sicp-ch2-构造数据抽象/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>SICP-CH2-构造数据抽象</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline21">1. 数据抽象索引</a>
<ul>
<li><a href="#orgheadline1">1.1. 实例:有理数的算术运算</a></li>
<li><a href="#orgheadline2">1.2. 习题2.1</a></li>
<li><a href="#orgheadline3">1.3. 抽象屏障</a></li>
<li><a href="#orgheadline4">1.4. 习题2.2</a></li>
<li><a href="#orgheadline5">1.5. 习题2.3</a></li>
<li><a href="#orgheadline6">1.6. 数据意味着什么</a></li>
<li><a href="#orgheadline7">1.7. 习题2.4</a></li>
<li><a href="#orgheadline8">1.8. 习题2.5</a></li>
<li><a href="#orgheadline9">1.9. 习题2.6</a></li>
<li><a href="#orgheadline10">1.10. 扩展练习:区间算术</a></li>
<li><a href="#orgheadline11">1.11. 习题2.7</a></li>
<li><a href="#orgheadline12">1.12. 习题2.8</a></li>
<li><a href="#orgheadline13">1.13. 习题2.9</a></li>
<li><a href="#orgheadline14">1.14. 习题2.10</a></li>
<li><a href="#orgheadline15">1.15. 习题2.11</a></li>
<li><a href="#orgheadline16">1.16. 习题2.12</a></li>
<li><a href="#orgheadline17">1.17. 习题2.13</a></li>
<li><a href="#orgheadline18">1.18. 习题2.14</a></li>
<li><a href="#orgheadline19">1.19. 习题2.15</a></li>
<li><a href="#orgheadline20">1.20. 习题2.16</a></li>
</ul>
</li>
<li><a href="#orgheadline98">2. 层次性数据和闭包性质</a>
<ul>
<li><a href="#orgheadline31">2.1. 序列的表示</a>
<ul>
<li><a href="#orgheadline22">2.1.1. 对表的操作</a></li>
<li><a href="#orgheadline23">2.1.2. 习题2.17</a></li>
<li><a href="#orgheadline24">2.1.3. 习题2.18</a></li>
<li><a href="#orgheadline25">2.1.4. 习题2.19</a></li>
<li><a href="#orgheadline26">2.1.5. 习题2.20</a></li>
<li><a href="#orgheadline27">2.1.6. 对表的映射</a></li>
<li><a href="#orgheadline28">2.1.7. 习题2.21</a></li>
<li><a href="#orgheadline29">2.1.8. 习题2.22</a></li>
<li><a href="#orgheadline30">2.1.9. 习题2.23</a></li>
</ul>
</li>
<li><a href="#orgheadline42">2.2. 层次结构</a>
<ul>
<li><a href="#orgheadline32">2.2.1. 习题2.24</a></li>
<li><a href="#orgheadline33">2.2.2. 习题2.25</a></li>
<li><a href="#orgheadline34">2.2.3. 习题2.26</a></li>
<li><a href="#orgheadline35">2.2.4. 习题2.27</a></li>
<li><a href="#orgheadline36">2.2.5. 习题2.28</a></li>
<li><a href="#orgheadline37">2.2.6. 习题2.29</a></li>
<li><a href="#orgheadline38">2.2.7. 对树的映射</a></li>
<li><a href="#orgheadline39">2.2.8. 习题2.30</a></li>
<li><a href="#orgheadline40">2.2.9. 习题2.31</a></li>
<li><a href="#orgheadline41">2.2.10. 习题2.32</a></li>
</ul>
</li>
<li><a href="#orgheadline56">2.3. 序列作为一种约定的界面</a>
<ul>
<li><a href="#orgheadline43">2.3.1. 序列操作</a></li>
<li><a href="#orgheadline44">2.3.2. 习题2.33</a></li>
<li><a href="#orgheadline45">2.3.3. 习题2.34</a></li>
<li><a href="#orgheadline46">2.3.4. 习题2.35</a></li>
<li><a href="#orgheadline47">2.3.5. 习题2.36</a></li>
<li><a href="#orgheadline48">2.3.6. 习题2.37</a></li>
<li><a href="#orgheadline49">2.3.7. 习题2.38</a></li>
<li><a href="#orgheadline50">2.3.8. 习题2.39</a></li>
<li><a href="#orgheadline51">2.3.9. 嵌套映射</a></li>
<li><a href="#orgheadline52">2.3.10. 习题2.40</a></li>
<li><a href="#orgheadline53">2.3.11. 习题2.41</a></li>
<li><a href="#orgheadline54">2.3.12. 习题2.42</a></li>
<li><a href="#orgheadline55">2.3.13. 习题2.43</a></li>
</ul>
</li>
<li><a href="#orgheadline67">2.4. 实例:一个图形语言</a>
<ul>
<li><a href="#orgheadline57">2.4.1. 习题2.44</a></li>
<li><a href="#orgheadline58">2.4.2. 习题2.45</a></li>
<li><a href="#orgheadline59">2.4.3. 习题2.46</a></li>
<li><a href="#orgheadline60">2.4.4. 习题2.47</a></li>
<li><a href="#orgheadline61">2.4.5. 习题2.48</a></li>
<li><a href="#orgheadline62">2.4.6. 习题2.49</a></li>
<li><a href="#orgheadline63">2.4.7. 习题2.50</a></li>
<li><a href="#orgheadline64">2.4.8. 习题2.51</a></li>
<li><a href="#orgheadline65">2.4.9. 强健的设计语言层次</a></li>
<li><a href="#orgheadline66">2.4.10. 练习2.52</a></li>
</ul>
</li>
<li><a href="#orgheadline72">2.5. 符号数据</a>
<ul>
<li><a href="#orgheadline68">2.5.1. 引号</a></li>
<li><a href="#orgheadline69">2.5.2. 习题2.53</a></li>
<li><a href="#orgheadline70">2.5.3. 习题2.54</a></li>
<li><a href="#orgheadline71">2.5.4. 习题2.55</a></li>
</ul>
</li>
<li><a href="#orgheadline78">2.6. 实例:符号求导</a>
<ul>
<li><a href="#orgheadline73">2.6.1. 对抽象数据的求导程序</a></li>
<li><a href="#orgheadline74">2.6.2. 代数表达式的表示</a></li>
<li><a href="#orgheadline75">2.6.3. 习题2.56</a></li>
<li><a href="#orgheadline76">2.6.4. 习题2.57</a></li>
<li><a href="#orgheadline77">2.6.5. 习题2.58</a></li>
</ul>
</li>
<li><a href="#orgheadline90">2.7. 实例:集合的表示</a>
<ul>
<li><a href="#orgheadline79">2.7.1. 集合作为未排序的表</a></li>
<li><a href="#orgheadline80">2.7.2. 习题2.59</a></li>
<li><a href="#orgheadline81">2.7.3. 习题2.60</a></li>
<li><a href="#orgheadline82">2.7.4. 集合作为排序的表</a></li>
<li><a href="#orgheadline83">2.7.5. 习题2.61</a></li>
<li><a href="#orgheadline84">2.7.6. 习题2.62</a></li>
<li><a href="#orgheadline85">2.7.7. 集合作为二叉树</a></li>
<li><a href="#orgheadline86">2.7.8. 习题2.63</a></li>
<li><a href="#orgheadline87">2.7.9. 习题2.64</a></li>
<li><a href="#orgheadline88">2.7.10. 习题2.65</a></li>
<li><a href="#orgheadline89">2.7.11. 习题2.66</a></li>
</ul>
</li>
<li><a href="#orgheadline97">2.8. 实例:Huffman编码树</a>
<ul>
<li><a href="#orgheadline91">2.8.1. 习题2.67</a></li>
<li><a href="#orgheadline92">2.8.2. 习题2.68</a></li>
<li><a href="#orgheadline93">2.8.3. 习题2.69</a></li>
<li><a href="#orgheadline94">2.8.4. 习题2.70</a></li>
<li><a href="#orgheadline95">2.8.5. 习题2.71</a></li>
<li><a href="#orgheadline96">2.8.6. 习题2.72</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline110">3. 抽象数据的多重表示</a>
<ul>
<li><a href="#orgheadline99">3.1. 复数的表示</a></li>
<li><a href="#orgheadline100">3.2. 带标志的数据</a></li>
<li><a href="#orgheadline106">3.3. 数据导向的程序设计和可加性</a>
<ul>
<li><a href="#orgheadline101">3.3.1. 习题2.73</a></li>
<li><a href="#orgheadline102">3.3.2. 习题2.74</a></li>
<li><a href="#orgheadline103">3.3.3. 消息传递</a></li>
<li><a href="#orgheadline104">3.3.4. 习题2.75</a></li>
<li><a href="#orgheadline105">3.3.5. 习题2.76</a></li>
</ul>
</li>
<li><a href="#orgheadline109">3.4. 带有通用型操作的系统</a>
<ul>
<li><a href="#orgheadline107">3.4.1. 通用型算术运算</a></li>
<li><a href="#orgheadline108">3.4.2. 习题2.77</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21"><span class="section-number-2">1</span> 数据抽象索引</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>数据抽象</code> 是一种科学方法,它使我们能将一个复合数据对象的使用,与该数据对象怎样由更基本的数据对象构造起来的细节隔离开.
</p>
</div>

<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> 实例:有理数的算术运算</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<code>表数据结构</code> 从序对构造起来的数据对象
</p>

<p>
关键字:cond, car, cdr
</p>

<p>
定义有理数过程:
</p>
<pre class="example">
;; 定义有理数并用gcd优化
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g)  (/ d g))))
;; 分子
(define (number x) (car x))
;; 分母
(define (denom x) (cdr x))
;; print
(define (print-rat x)
  (newline)
  (display (number x))
  (display "/")
  (display (denom x)))
;; test val-&gt;1/2
(print-rat (make-rat 2 -4))
</pre>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> 习题2.1</h3>
<div class="outline-text-3" id="text-1-2">
<pre class="example">
(define (make-rat n d)
  (let ((g (gcd (abs n) (abs d))))
    (cond ((&gt; (* n d) 0)
           (cons (/ (abs n) g)  (/ (abs d) g)))
          (else  (cons (- 0 (/ (abs n) g)) (/ (abs d) g))))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> 抽象屏障</h3>
<div class="outline-text-3" id="text-1-3">
<p>
数据抽象的基本思想是:为每一类数据对象标识出一组操作,使得对这类数据对象的操作都可以基于它们表述,并且只使用它们.
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> 习题2.2</h3>
<div class="outline-text-3" id="text-1-4">
<pre class="example">
(define (make-point x y) (cons x y))
(define (x-point x) (car x))
(define (y-point x) (cdr x))
(define (make-segment x y) (cons x y))
(define (start-point x) (car x))
(define (end-point x) (cdr x))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(define (mid-point segment)
  (print-point (make-point
   (/ (+ (x-point (start-point segment)) (x-point (end-point segment))) 2)
   (/ (+ (y-point (start-point segment)) (y-point (end-point segment))) 2))))

(mid-point (make-segment (make-point 1.0 1.0) (make-point 4 5)))
;; value-&gt; (2.5,3.)
</pre>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.5</span> 习题2.3</h3>
<div class="outline-text-3" id="text-1-5">
<pre class="example">
(define (double x) (* x x))
(define (make-rect p1 p2 p3)
  (cons (make-segment p1 p2) (make-segment p2 p3)))
(define (h-side rect) (car rect))
(define (v-side rect) (cdr rect))
(define (lenth seg)
  (let ((p1 (x-point seg))
        (p2 (y-point seg)))
  (sqrt
   (+
    (double (- (x-point p1) (x-point p2)))
    (double (- (y-point p1) (y-point p2)))))))
(define (rect-length rect)
  (* (+
      (lenth (h-side rect))
      (lenth (v-side rect)))
     2))
(define (rect-area rect)
  (*  (lenth (h-side rect))
      (lenth (v-side rect))))

;; test
(lenth (make-segment (make-point 1 1) (make-point 2 2))) 
;Value: 1.4142135623730951

(rect-length
 (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
;Value: 6.82842712474619

(rect-area
 (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
;Value: 2.8284271247461903
</pre>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">1.6</span> 数据意味着什么</h3>
<div class="outline-text-3" id="text-1-6">
<p>
<code>数据</code> 是一组适当的 <b>构造函数</b> 和 <b>选择函数</b> ,以及为了使这些过程成为一套合法的表示, 它们必须满足的一组*特定条件*
</p>

<p>
条件可能不太好理解, 举例来说, <b>序对</b> 这种数据的car和cdr操作需要满足的条件就是:
任何对象x和y, 如果z是(cons x y),那么(car z)就是x, (cdr z)就是y.
</p>

<p>
<code>数据的过程性表示</code> lisp/scheme甚至可以用过程来表示序对:
</p>
<pre class="example">
(define (cons x y)
 (define (dispatch m)
   (cond ((= m 0) x)
         ((= m 1) y)
         (else (error "argument not 0 or 1")))
  dispatch))

(define (car z) (z 0))
(define (cdr z) (z 1))
</pre>

<p>
(cons x y)返回一个过程. 当然scheme和一般的lisp并不会这样实现序对,主要是出于性能考虑.
</p>

<p>
在第三章可以看到,数据的过程性表示在设计中扮演着一种重要的角色,这种风格叫做 <code>消息传递</code>
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">1.7</span> 习题2.4</h3>
<div class="outline-text-3" id="text-1-7">
<p>
代换过程:
</p>
<pre class="example">
(car (cons x y))
((cons x y) (lambda (p q) p))
;把(lambda (p q))作为m带入(lambda (m) (m x y))
((lambda (p q) p) x y)
;应用x,y,得到
value-&gt;x
</pre>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">1.8</span> 习题2.5</h3>
<div class="outline-text-3" id="text-1-8">
<p>
2和3都是质数,可以利用质数相乘的性质储存a和b.
</p>
<pre class="example">
(define (cons-expt x y)
  (* (expt 2 x) (expt 3 y)))

(define (car-expt x)
  (define (iter a n)
    (cond ((= 0 (remainder a 2)) (iter (/ a 2) (+ n 1)))
          (else n)))
  (iter x 0))

(define (cdr-expt x)
  (define (iter a n)
    (cond ((= 0 (remainder a 3)) (iter (/ a 3) (+ n 1)))
          (else n)))
  (iter x 0))

(car-expt (cons-expt 5 6)) ;value-&gt;5
(cdr-expt (cons-expt 5 6)) ;value-&gt;6
</pre>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">1.9</span> 习题2.6</h3>
<div class="outline-text-3" id="text-1-9">
<p>
使用church计数的表示形式定义one和two. (讲真我对着这道题发呆好久&#x2026;.
</p>

<pre class="example">
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f (n f) x))))

; 首先展开add-1
(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
(lambda (f) (lambda (x) (f ((lambda(x) x) x))))
(lambda (f) (lambda (x) (f x)))
(add-1 one)
(lambda (f) (lambda (x) (f ((one f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))
; 定义one
(define one (lambda (f) (lambda (x) (f x))))
; 定义two
(define two (lambda (f) (lambda (x) (f (f x)))))
;根据观察得出规律规律:one的定义中应用了一次f, two的定义中应用了2次f, 所以这类过程可以理解为用'应用f的次数'来表示数字.
</pre>
<p>
定义通用的加法:
</p>
<pre class="example">
(define (add a b)
  (lambda(f) (lambda(x) ((a f) ((b f) x)))))
</pre>
<p>
这个定义的思路是把a和b中应用f的过程叠加. 下面测试一下:
</p>
<pre class="example">
(add one two)
(lambda(f) (lambda(x) ((lambda(x) (f x)) ((lambda(x) (f (f x))) x))))
(lambda(f) (lambda(x) ((lambda(x) (f x)) (f (f x)))))
(lambda(f) (lambda(x) (f (f (f x)))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">1.10</span> 扩展练习:区间算术</h3>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">1.11</span> 习题2.7</h3>
<div class="outline-text-3" id="text-1-11">
<pre class="example">
(define (make-interval a b) (cons a b))
(define (upper-bound x) (car x))
(define (lower-bound x) (cdr x))
</pre>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">1.12</span> 习题2.8</h3>
<div class="outline-text-3" id="text-1-12">
<pre class="example">
(define (sub-interval a b)
  (make-interval (- (upper-bound a) (upper-bound b))
                 (- (lower-bound a) (lower-bound b))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.13</span> 习题2.9</h3>
<div class="outline-text-3" id="text-1-13">
<p>
对加/减运算而言:
\(w(a+b)=(u(a+b)-l(a+b))/2=(((u(a)+u(b))-(l(a)+l(b)))/2=(w(a)+w(b))\)
所以两个区间的和/差的宽度函数就是被加/减的区间的宽度函数.
</p>

<p>
对乘法而言:
</p>

<p>
有区间A=[0,2],宽度为1;B=[0,4],宽度为2;
A*B=[0,8],宽度为4. 所以\(w(A*B)\neq w(A)*w(B)\).
</p>

<p>
对除法而言:
A/B=[0,1/2],宽度为1/4. 而w(A)/w(B)=1/2; 所以\(w(A/B)\neq w(A)/w(B)\).
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">1.14</span> 习题2.10</h3>
<div class="outline-text-3" id="text-1-14">
<pre class="example">
; 首先定义一个检查过程
(define (valid-interval x)
  (if (&lt; (* (upper-bound x) (lower-bound x)) 0) false true))
; 重新定义除法
(define (div-interval x y)
  (if (and (valid-interval x) (vali-interval y))
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))
      (display "error:invalid param")))
</pre>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">1.15</span> 习题2.11</h3>
<div class="outline-text-3" id="text-1-15">
<p>
根据区间是否跨过0|是否全为正|是否全为负分为9种情况.
</p>
<ul class="org-ul">
<li>a &gt; 0, b &gt; 0</li>
<li>a &gt; 0, b &lt; 0</li>
<li>a &gt; 0, b cross 0</li>
<li>a cross 0, b &gt; 0</li>
<li>a cross 0, b &lt; 0</li>
<li>a cross 0, b cross 0</li>
<li>a &lt; 0, b &gt; 0</li>
<li>a &lt; 0, b &lt; 0</li>
<li>a &lt; 0, b cross 0</li>
</ul>

<p>
定义快速乘法(有个问题..当a和b都跨越0时,需要4次乘法运算)
</p>
<pre class="example">
(define (is-cross-zero x)
  (if (&lt; (* (upper-bound x) (lower-bound x)) 0) true false))
(define (is-positive x)
  (if (&gt;= (lower-bound x) 0) true false))
(define (is-negative x)
  (if (&lt; (upper-bound x) 0) true false))

(define (fast-mul-interval x y)
  (cond
   ((and (is-positive x) (is-positive y))
    (make-interval
     (* (lower-bound x) (lower-bound y))
     (* (upper-bound x) (upper-bound y))))
   ((and (is-positive x) (is-negative y))
    (make-interval
     (* (upper-bound x) (upper-bound y))
     (* (lower-bound x) (lower-bound y))))
   ((and (is-positive x) (is-cross-zero y))
    (make-interval
     (* (upper-bound x) (lower-bound y))
     (* (upper-bound x) (upper-bound y))))
   ((and (is-negative x) (is-positive y))
    (make-interval
     (* (lower-bound x) (upper-bound y))
     (* (upper-bound x) (lower-bound y))))
   ((and (is-negative x) (is-negative y))
    (make-interval
     (* (upper-bound x) (upper-bound y))
     (* (lower-bound x) (lower-bound y))))
   ((and (is-negative x) (is-cross-zero y))
    (make-interval
     (* (lower-bound x) (upper-bound y))
     (* (lower-bound x) (lower-bound y))))
   ((and (is-cross-zero x) (is-positive y))
    (make-interval
     (* (lower-bound x) (upper-bound y))
     (* (upper-bound x) (upper-bound y))))
   ((and (is-cross-zero x) (is-negative y))
   (make-interval
    (* (upper-bound x) (lower-bound y))
    (* (lower-bound x) (lower-bound y))))
  ((and (is-cross-zero x) (is-cross-zero y))
   (make-interval
    (min (* (lower-bound x) (upper-bound y)) (* (upper-bound x) (lower-bound y)))
    (max (* (upper-bound x) (upper-bound y)) (* (lower-bound x) (lower-bound y)) )))))
</pre>

<p>
与Alyssa的暴力乘法进行比较测试(吐血&#x2026;
</p>
<pre class="example">
(fast-mul-interval (make-interval 1 2) (make-interval 1 2))
(mul-interval (make-interval 1 2) (make-interval 1 2))
;; Value : (1 . 4)

(fast-mul-interval (make-interval 1 2) (make-interval -1 -2))
(mul-interval (make-interval 1 2) (make-interval -1 -2))
;; Value : (-4 .-1)

(fast-mul-interval (make-interval 1 2) (make-interval -1 2))
(mul-interval (make-interval 1 2) (make-interval -1 2))
;; Value : (-2, 4)

(fast-mul-interval (make-interval -2 -1) (make-interval 1 2))
(mul-interval (make-interval -2 -1) (make-interval 1 2))
;; Value : (-4, -1)

(fast-mul-interval (make-interval -2 -1) (make-interval -2 -1))
(mul-interval (make-interval -2 -1) (make-interval -2 -1))
;; Value : (1, 4)

(fast-mul-interval (make-interval -2 -1) (make-interval -1 2))
(mul-interval (make-interval -2 -1) (make-interval -1 2))
;; Value : (-4, 2)

(fast-mul-interval (make-interval -2 1) (make-interval 1 2))
(mul-interval (make-interval -2 1) (make-interval 1 2))
;; Value : (-4, 2)

(fast-mul-interval (make-interval -2 1) (make-interval -2 -1))
(mul-interval (make-interval -2 1) (make-interval -2 -1))
;; Value : (-2, 4)

(fast-mul-interval (make-interval -2 1) (make-interval -5 2))
(mul-interval (make-interval -2 1) (make-interval -5 2))
;; Value : (-5, 10)
</pre>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">1.16</span> 习题2.12</h3>
<div class="outline-text-3" id="text-1-16">
<pre class="example">
(define (make-center-percent center percent)
  (make-interval (- center (* center percent))
                 (+ center (* center percent))))
(define (percent range)
  (let ((width (/ (- (upper-bound range) (lower-bound range)) 2))
        (mid (/ (+ (upper-bound range) (lower-bound range)) 2)))
        (/ width mid)))
</pre>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">1.17</span> 习题2.13</h3>
<div class="outline-text-3" id="text-1-17">
<p>
计算精度的公式是简单相加:
</p>
<pre class="example">
(define (percent-mul r1 r2)
  (+ (percent r1) (percent r2)))
</pre>
<p>
测试一下
</p>
<pre class="example">
(percent (mul-interval (make-interval 9.99 10.01) (make-interval 9.99 10.01)))
(percent-mul (make-interval 9.99 10.01) (make-interval 9.99 10.01))
</pre>


<p>
然后分析part1,part2的问题:
</p>
<pre class="example">
(define (part1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (part2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))

(part1 (make-interval 1 2) (make-interval 1 2)) ;val-&gt; (.25,2)
(part2 (make-interval 1 2) (make-interval 1 2)) ;val-&gt; (.5 1)
</pre>
<p>
猜测是运算顺序不同导致精度变化不同
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">1.18</span> 习题2.14</h3>
<div class="outline-text-3" id="text-1-18">
<p>
首先验证上面的猜测
</p>
<pre class="example">
(let ((r1 (make-interval 1.0 2))
       (r2 (make-interval 1.0 2))
      (one (make-interval 1.0 1.0)))
  (percent r1)  ; .33
  (percent (mul-interval r1 r2)) ; .6 放大2倍
  (percent (div-interval r1 r2)) ; .6 放大2倍
  (percent (add-interval r1 r2)) ; .33 不变
  (percent (div-interval one r1)) ; .33 不变
  (percent (part1 r1 r2)) ; .77 放大2.28倍
  (percent (part2 r1 r2)) ; .33 
  )
</pre>

<p>
可见,直接对两个区间进行乘法或除法操作会将精度放大.而加法以及被one除不会放大精度.
</p>

<p>
在part1的运算过程中,乘法将精度放大2倍, 用放大的乘积除以和之后从0.6放大到0.77. 
而在part2中,由于全是除以1的操作.精度没有发生变化.
</p>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">1.19</span> 习题2.15</h3>
<div class="outline-text-3" id="text-1-19">
<p>
eva说的对. part2中的运算都没有造成精度区间扩大,所以是更好的程序.
</p>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">1.20</span> 习题2.16</h3>
<div class="outline-text-3" id="text-1-20">
<p>
(作者说此题非常难&#x2026;怕
</p>

<p>
我先想到了除法运算可能长这样:
</p>
<pre class="example">
(define (better-div-interval r1 r2)
  (let ((one (make-interval 1 1)))
    (better-mul-interval r1  (div-interval one r2))))
</pre>
<p>
但首先要能定义出一个better-mul-interval
</p>

<p>
我实在编不下去了! google了一下,这道题真的很难,涉及到比较艰深的数学问题. 贴个链接在这里吧:
<a href="http://stackoverflow.com/questions/14130878/sicp-2-16-interval-arithmetic-scheme">http://stackoverflow.com/questions/14130878/sicp-2-16-interval-arithmetic-scheme</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline98" class="outline-2">
<h2 id="orgheadline98"><span class="section-number-2">2</span> 层次性数据和闭包性质</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>操作的闭包性质</code> 通过某种操作组合起来的数据对象得到的结果本身还可以通过同样的操作再进行组合.
</p>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">2.1</span> 序列的表示</h3>
<div class="outline-text-3" id="text-2-1">
<p>
序列可以通过嵌套cons操作构造起来
</p>
<pre class="example">
(cons 1
    (cons 2
        (cons 3
            (cons 4 ))))
</pre>

<p>
scheme为了方便表的构造而提供了一个基本操作list.所以上面序列也可以通过以下方式产生:
</p>
<pre class="example">
(list 1 2 3 4)
</pre>
<p>
它们是等价的.
</p>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">2.1.1</span> 对表的操作</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
<code>car</code> 可以被看做获取表第一项元素的操作
<code>cdr</code> 可以看做获取表剩下的元素的操作
<code>nil</code> 用于表示序对链的结束
</p>

<p>
可以这样实现索引:
</p>
<pre class="example">
(define (list-ref item n)
  (if (= n 0)
      (car item)
      (list-ref (cdr item) (- n 1))))
</pre>

<p>
<code>null?</code> 用于检查是否是空表.
利用null实现length:
</p>
<pre class="example">
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23"><span class="section-number-4">2.1.2</span> 习题2.17</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
获取序列的最后一个元素
</p>
<pre class="example">
(define (last-pair items)
  (if (= 1 (length items))
      (list (car items))
      (last-pair (cdr items))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">2.1.3</span> 习题2.18</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
返回逆序序列
</p>
<pre class="example">
(define (reverse items)
  (if (= 1 (length items))
      items
      (append (reverse (cdr items)) (list (car items)))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">2.1.4</span> 习题2.19</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
利用序列优化1.22的找硬币程序,把币种存储在序列中
</p>
<pre class="example">
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
(define (except-first-denomination coin-values) (cdr coin-values))
(define (first-denomination coin-values) (car coin-values))
(define (no-more? coin-values) (if (null? coin-values) true false))
(define (cc amount coin-values)
  (cond ((= amount 0 ) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</pre>
<p>
币种的排序不会影响结果.因为针对每种硬币,都会从总金额amount开始重新计算, 测试结果是互相独立的.
</p>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">2.1.5</span> 习题2.20</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
这道题说明了scheme怎样定义带有任意多参数的过程
</p>

<p>
具体方式是使用点尾:
</p>
<pre class="example">
(define (f x y . z) &lt;body&gt;)
</pre>
<p>
那么如果求值(f 1 2 3 4 5),则x=1,y=2,然后z=(3,4,5),是一个list. (原来是这样&#x2026;
</p>

<p>
请用这种记法写出same-parity:返回与其第一个参数有同样奇偶性质的表
</p>
<pre class="example">
;首先定义一个选择器,它接受一个过程参数f,然后用f来过滤出子序列
(define (filter items f)
  (cond
   ((null? items) (list))
   ((f (car items))
    (append (list (car items)) (filter (cdr items) f)))
   (else
    (append (list) (filter (cdr items) f)))))
</pre>
<p>
然后定义same-party.为了简化我首先利用append把x,y,z整合成一个序列
</p>
<pre class="example">
(define (same-party x y . z)
  (let ((param-list
         (append (list x) (append (list y) z))))
    (if
     (odd? x)
     (filter param-list odd?)
     (filter param-list even?))))
</pre>
<p>
测试
</p>
<pre class="example">
(same-party 2 1 2 3 4 5 6 7 8) ; value: (1 3 5 7)
(same-party 1 2 3 4 5 6 7 8)   ; value: (2 2 4 6 8)
</pre>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">2.1.6</span> 对表的映射</h4>
<div class="outline-text-4" id="text-2-1-6">
<p>
<code>map</code> 是一种公共模式,而且建立起了一种处理表的高层抽象
</p>
<pre class="example">
(define (map proc items)
  (if (null? items)
      (list)
      (cons (proc (car items))
            (map proc (cdr items)))))
</pre>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-4">
<h4 id="orgheadline28"><span class="section-number-4">2.1.7</span> 习题2.21</h4>
<div class="outline-text-4" id="text-2-1-7">
<pre class="example">
(define (square-list items)
  (if (null? items)
      '()
      (cons (square (car items)) (square-list (cdr items)))))

(define (square-list items)
  (map square items))
</pre>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-4">
<h4 id="orgheadline29"><span class="section-number-4">2.1.8</span> 习题2.22</h4>
<div class="outline-text-4" id="text-2-1-8">
<p>
第一个迭代错在cons的顺序,把answer放在最后会变成倒序
</p>
<pre class="example">
(cons (...) answer)
</pre>
<p>
而修改后的程序把answer放在前面,虽然看起来顺序对了,但cons的第一个参数是嵌套的cons,最后生成的序列会长这样:
</p>
<pre class="example">
((((. .) .) .) .)
</pre>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30"><span class="section-number-4">2.1.9</span> 习题2.23</h4>
<div class="outline-text-4" id="text-2-1-9">
<p>
实现一个for-each
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (for-each proc items)
  (if (null? items)
       ()
       (begin
         (proc (car items))
         (for-each proc (cdr items)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-3">
<h3 id="orgheadline42"><span class="section-number-3">2.2</span> 层次结构</h3>
<div class="outline-text-3" id="text-2-2">
<p>
将表作为序列的方式,可以自然的推广到表示那些元素本身也是序列的序列,也就是
<code>树</code>. 
</p>

<p>
<code>pair?</code> scheme提供的基本过程, 检查参数是否为序对.
</p>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">2.2.1</span> 习题2.24</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-scheme">(list 1 (list 2 (list 3 4) 5))
;Value 89: (1 (2 (3 4) 5))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">     N
  /     \
1        N    
       / | \  
      2  N  5
        / \
       3   4
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">2.2.2</span> 习题2.25</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-scheme">(cdr (car (cdr (cdr mt1))))
(cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr mt2)))))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34"><span class="section-number-4">2.2.3</span> 习题2.26</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-scheme">(append x y) ;Value 101: (1 2 3 4 5 6)
(cons x y)   ;Value 102: ((1 2 3) 4 5 6)
(list x y)   ;Value 103: ((1 2 3) (4 5 6))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35"><span class="section-number-4">2.2.4</span> 习题2.27</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
实现深度逆序.这道题目真是折腾死宝宝了,一开始有个关键点没搞明白,导致瞎写了一通.
这个关键的地方是:如果(cdr list)是一个list:
</p>
<pre class="example">
(list 1 (list 2 3))
</pre>
<p>
那么它的逆序则是
</p>
<pre class="example">
(append (cdr list) (car list))
</pre>
<p>
但如果(car list)是list,就稍微有点绕:
</p>
<pre class="example">
(list (list 1 2) 3)
</pre>
<p>
那么它的逆序则是
</p>
<pre class="example">
(append (cdr list) (list (car list)))
</pre>
<p>
原因是append或者cons会把第二个参数展开(去掉一层list), 所以不能直接使用(car x)当做第二个参数.           
</p>

<p>
深度逆序:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (deep-revers tree)
  (cond
   ((null? tree) ())
   ((not (pair? tree)) (list tree))
   ((pair? (car tree))
      (append (deep-revers (cdr tree)) (list (deep-revers (car tree)))))
   (else
      (append (deep-revers (cdr tree)) (deep-revers (car tree))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36"><span class="section-number-4">2.2.5</span> 习题2.28</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-scheme">(define (fringe tree)
  (cond
   ((null? tree) ())
   ((not (pair? tree)) (list tree))
   (else
    (append (fringe (car tree))
            (fringe (cdr tree)))
        )))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-4">
<h4 id="orgheadline37"><span class="section-number-4">2.2.6</span> 习题2.29</h4>
<div class="outline-text-4" id="text-2-2-6">
<p>
-a) 获取左右子树,右子树稍稍注意:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))
</pre>
</div>

<ul class="org-ul">
<li>b) 递归计算子树长度(左边叶子之和)</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (branch-length branch)
  (cond
   ((null? branch) 0)
   ((not (pair? branch)) 0)
   (else
    (+ (car branch) (branch-length (right-branch branch))))))
</pre>
</div>

<p>
递归计算重量(右叶子之和)
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (branch-weight branch)
  (cond
   ((null? branch) 0)
   ((not (pair? branch)) branch)
   (else
    (branch-weight (right-branch branch)))))

(define (total-weight mobile)
  (+
   (branch-length (left-branch mobile))
   (branch-length (right-branch mobile))))
</pre>
</div>

<ul class="org-ul">
<li>c) 计算是否平衡,简单的乘法.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (is-balance mobile)
  (=
   (* (branch-weight (left-branch mobile)) (branch-length (left-branch mobile)))
   (* (branch-weight (left-branch mobile)) (branch-length (right-branch mobile)))))
</pre>
</div>

<ul class="org-ul">
<li>d) 只需修改right-branch方法</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (right-branch mobile)
  (cdr mobile))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38"><span class="section-number-4">2.2.7</span> 对树的映射</h4>
<div class="outline-text-4" id="text-2-2-7">
<p>
把map与递归结合是处理树的一种强有力的抽象
</p>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">2.2.8</span> 习题2.30</h4>
<div class="outline-text-4" id="text-2-2-8">
<p>
定义square-tree
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (map-tree tree f)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (map-tree sub-tree f)
             (f sub-tree)))
       tree))
(map-tree (list 1 2 (list 3 4)) square)
; value: (1 4 (9 16))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-4">
<h4 id="orgheadline40"><span class="section-number-4">2.2.9</span> 习题2.31</h4>
<div class="outline-text-4" id="text-2-2-9">
<p>
将2.30进一步抽象. (还好宝宝机智,已经抽象好了
</p>
<pre class="example">
(define (square-tree tree) (map-tree tree square))
</pre>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-4">
<h4 id="orgheadline41"><span class="section-number-4">2.2.10</span> 习题2.32</h4>
<div class="outline-text-4" id="text-2-2-10">
<p>
计算全排列(又学到一种算排列的新姿势
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (subsets s)
  (if (null? s)
      ()
      (let ((reset (subsets (cdr s))))
        (append reset
                (cons
                 (car s) 
                 (map (lambda (sub) (append (car s) sub)) reset))))))
</pre>
</div>
<p>
倒数第3行用cons比较安全. 如果(map..)计算结果是nil, 则cons会把nil省略而list或append会把()放进结果中.
作这道题一开始append结果总跟预想的不一样,经测试(append 1 2)的结果是个序对(1 . 2)而不是list(1 2).
后来修改了之前的append实现才搞定:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (append list1 list2)
  (cond ((null? list1)
         list2)
        ((null? list2) ;; 对list2=nil的情况进行处理
         list1)
        ((and (not (pair? list1)) (not (pair? list2)))
         (list list1 list2)) ;; 两个都是简单数据时返回list,而不是序对
        ((not (pair? list1))
         (cons list1 list2)) ;; list1是简单数据时直接cons,否则后面会对它car/cdr
        (else
         (cons (car list1) (append (cdr list1) list2)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline56" class="outline-3">
<h3 id="orgheadline56"><span class="section-number-3">2.3</span> 序列作为一种约定的界面</h3>
<div class="outline-text-3" id="text-2-3">
<p>
这里介绍与数据结构有关的另一种强有力的设计原理 <b>使用约定的界面</b>.
</p>

<p>
举个例子,定义一个过程,枚举所有叶子,并计算出那些值为奇数的叶子的平方和.
这个过程可以抽象成一个信号流:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">enumerate:</td>
<td class="org-left">filter:</td>
<td class="org-left">map:</td>
<td class="org-left">accumulate:</td>
</tr>

<tr>
<td class="org-left">tree leaves</td>
<td class="org-left">odd?</td>
<td class="org-left">square</td>
<td class="org-left">+, 0</td>
</tr>
</tbody>
</table>
<p>
如果我们能良好的组织成熟,使得 <code>信号流结构</code> 明显的表现在写出的过程中,将会大大提高代码的清晰性.
</p>
</div>

<div id="outline-container-orgheadline43" class="outline-4">
<h4 id="orgheadline43"><span class="section-number-4">2.3.1</span> 序列操作</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
要清晰的反应信号流结构, 最关键的一点就是将注意力集中在处理过程从一个步骤流向下一个步骤的"信号".
</p>

<ul class="org-ul">
<li><b>map</b> 可以利用2.2.1节的map来表现信号流图中的映射步骤.</li>
</ul>
<pre class="example">
(map square (list 1 2 3 4 5)
</pre>

<ul class="org-ul">
<li><b>filter</b></li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (filter predicate sequence)
  (cond ((null? sequence) ())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
</pre>
</div>

<ul class="org-ul">
<li><b>accumulate</b> 定义计算步骤</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
</pre>
</div>

<ul class="org-ul">
<li><b>enumerate</b> 定义树的枚举</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (enumerate-tree tree)
  (cond ((null? tree) ())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
</pre>
</div>

<p>
利用这些步骤来定义前面的例子:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
</pre>
</div>

<p>
这样我们就得到了一个由许多独立程序片段组合构成的设计.
</p>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-4">
<h4 id="orgheadline44"><span class="section-number-4">2.3.2</span> 习题2.33</h4>
<div class="outline-text-4" id="text-2-3-2">
<div class="org-src-container">

<pre class="src src-scheme">(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) () sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-4">
<h4 id="orgheadline45"><span class="section-number-4">2.3.3</span> 习题2.34</h4>
<div class="outline-text-4" id="text-2-3-3">
<div class="org-src-container">

<pre class="src src-scheme">(define (horner-eval x sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              sequence))

(horner-eval 2 (list 1 3 0 5 0 1));Value: 79
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46"><span class="section-number-4">2.3.4</span> 习题2.35</h4>
<div class="outline-text-4" id="text-2-3-4">
<div class="org-src-container">

<pre class="src src-scheme">(define (count-leaves t)
  (accumulate (lambda (x y) (+ x y))
              0
              (map (lambda (x) (length (enumerate-tree x))) t)))
(count-leaves (list 1 2 (list 2 3 4))) ; Value:5
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47"><span class="section-number-4">2.3.5</span> 习题2.36</h4>
<div class="outline-text-4" id="text-2-3-5">
<div class="org-src-container">

<pre class="src src-scheme">(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      ()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 1 2 3)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">2.3.6</span> 习题2.37</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
实现矩阵点的各种基本运算
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (dot-product v w)
  (accumulate + 0 (accumulate-n * 1 (list v w))))

(define (matrix-*-vector m v)
  (map
   (lambda (x) (dot-product x v))
   m))
(define (transpose m)
  (accumulate-n (lambda (x y) (cons x y)) () m))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (col) (matrix-*-vector m col)) cols)))
</pre>
</div>
<p>
测试:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define mv (list 1 2 3))
(define mm (list (list 1 2 3) (list 4 5 6) (list 4 5 6)))
(dot-product mv mv);Value: 14
(matrix-*-vector mm mv);Value 269: (14 32 32)
(transpose mm);Value 266: ((1 4) (2 5) (3 6))
(matrix-*-matrix mm mm);Value 268: ((21 48 48) (27 63 63) (33 78 78))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49"><span class="section-number-4">2.3.7</span> 习题2.38</h4>
<div class="outline-text-4" id="text-2-3-7">
<div class="org-src-container">

<pre class="src src-scheme">(fold-right / 1 (list 1 2 3)) ;;Value: 3/2
(fold-left / 1 (list 1 2 3))  ;;Value: 1/6
(fold-right list () (list 1 2 3));Value 270: (1 (2 (3 ())))
(fold-left list () (list 1 2 3));Value 271: (((() 1) 2) 3)
</pre>
</div>
<p>
保证fold-right和fold-left都相同的条件是,运算满足交换律.
</p>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-4">
<h4 id="orgheadline50"><span class="section-number-4">2.3.8</span> 习题2.39</h4>
<div class="outline-text-4" id="text-2-3-8">
<div class="org-src-container">

<pre class="src src-scheme">(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) () sequence))
  (define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) ()  sequence))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51"><span class="section-number-4">2.3.9</span> 嵌套映射</h4>
<div class="outline-text-4" id="text-2-3-9">
<p>
我们可以扩充序列泛型,将许多通常用嵌套循环表述的计算包含进来,  比如用append累积map的计算结果:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (flatmap proc seq)
  (accumulate append (list) (map proc seq)))
</pre>
</div>

<ul class="org-ul">
<li>ep1: 找出n以下所有和为素数的序对:</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)
                ))))
</pre>
</div>

<ul class="org-ul">
<li>ep2: 全排列</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (permutations s)
  (if (null? s)
      (list (list))
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline52" class="outline-4">
<h4 id="orgheadline52"><span class="section-number-4">2.3.10</span> 习题2.40</h4>
<div class="outline-text-4" id="text-2-3-10">
<div class="org-src-container">

<pre class="src src-scheme">(define (unique-pairs low high)
  (flatmap (lambda (x) 
         (map (lambda (y) (list x y))
              (enumerate-interval (+ x 1) high)))
           (enumerate-interval low high)))
(unique-pairs 1 3);;=&gt; ((1 2) (1 3) (2 3))
(define (prime-sum-pair n)
  (filter prime-sum? (unique-pairs 1 n)))
(prime-sum-pair 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">2.3.11</span> 习题2.41</h4>
<div class="outline-text-4" id="text-2-3-11">
<div class="org-src-container">

<pre class="src src-scheme">(define (unique-triples low high)
  (flatmap (lambda (x)
             (map (lambda (i) (append x i)) (unique-pairs (+ x 1) high)))
           (enumerate-interval low high)))
(unique-triples 1 4)
(define (prime-sum-triple? list)
  (prime? (+ (car list) (cadr list) (cadr (cdr list)))))
(define (prime-sum-triples n)
  (filter prime-sum-triple? (unique-triples 1 n)))
(prime-sum-triples 4) ;;=&gt; ((1 2 4) (2 3 4))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54"><span class="section-number-4">2.3.12</span> 习题2.42</h4>
<div class="outline-text-4" id="text-2-3-12">
<p>
经典的8皇后问题,回溯法.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (queens board-size)
  (define (queen-cols k)
    (if (= 0 k)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
        (queen-cols board-size))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define empty-board (list))
</pre>
</div>
<p>
空棋盘就是nil
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))
</pre>
</div>
<p>
k其实没有用到,大概留出这个参数是为了便于替换成其它算法.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(define (safe? k positions)
  (define (safe-iter x rest distance)
    (cond ((null? rest) #t)
          ((= x (car rest)) #f)
          ((= distance (abs (- x (car rest)))) #f)
          (else (safe-iter x (cdr rest) (+ distance 1)))))
  (safe-iter (car positions) (cdr positions) 1))
(queens 4);;Value 458: ((3 1 4 2) (2 4 1 3))
</pre>
</div>
<p>
遍历rest, 检查相同行中是否存在皇后, 以及对角线是否存在皇后.
</p>
</div>
</div>

<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55"><span class="section-number-4">2.3.13</span> 习题2.43</h4>
<div class="outline-text-4" id="text-2-3-13">
<p>
2.42解法只需要递归的计算一遍queen-cols,而Reasoner需要递归T遍,导致最后解题事件变成了
 \(T*board-size\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-3">
<h3 id="orgheadline67"><span class="section-number-3">2.4</span> 实例:一个图形语言</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在描述一种语言时,应该将注意力集中在语言的基本原语,它的组合以及抽象手段.
这一图形语言的优美之处,部分在于语言中只有一个元素,称为画家painter.
</p>
</div>

<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">2.4.1</span> 习题2.44</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">

<pre class="src src-scheme">(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (up painter (right smaller smaller)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58"><span class="section-number-4">2.4.2</span> 习题2.45</h4>
<div class="outline-text-4" id="text-2-4-2">
<div class="org-src-container">

<pre class="src src-scheme">(define (split t1 t2)
  (define (process painter n)
    (if (= n 0)
        painter
        (let ((process painter (- n 1)))
          (let ((part (t2 smaller smaller)))
            (t1 painter part)))))
    (lambda (painter n) (process painter n)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline59" class="outline-4">
<h4 id="orgheadline59"><span class="section-number-4">2.4.3</span> 习题2.46</h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">

<pre class="src src-scheme">(define (make-vect x y) (cons x y))
(define (xcor-vect rect) (car rect))
(define (ycor-vect rect) (cdr rect))
(define (add-vect v1 v2)
  (make-vect
   (+ (xcor-vect v1) (xcor-vect v2))
   (+ (ycor-vect v1) (ycor-vect v2))))
(define (sub-vect v1 v2)
  (make-vect
   (- (xcor-vect v1) (xcor-vect v2))
   (- (ycor-vect v1) (ycor-vect v2))))
(define (scale-vect s v)
  (make-vect
   (* s (xcor-vect v))
   (* s (ycor-vect v))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60"><span class="section-number-4">2.4.4</span> 习题2.47</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
方案1:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (origin-frame frame) (car frame))
(define (edge1-frame frame) (cadr frame))
(define (edge2-frame frame) (caddr frame))
</pre>
</div>
<p>
方案2:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (origin-frame frame) (car frame))
(define (edge1-frame frame) (cadr frame))
(define (edge2-frame frame) (cddr frame))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline61" class="outline-4">
<h4 id="orgheadline61"><span class="section-number-4">2.4.5</span> 习题2.48</h4>
<div class="outline-text-4" id="text-2-4-5">
<div class="org-src-container">

<pre class="src src-scheme">(define (make-segment v1 v2) (cons v1 v2))
(define (start-segment seg) (car seg))
(define (end-segment seg) (cdr seg))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62"><span class="section-number-4">2.4.6</span> 习题2.49</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
首先定义一堆获取顶点/边/中点的过程&#x2026;(吐血)&#x2026;
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (top-left frame) (add-vect (origin-frame frame) (edge1-frame frame)))
(define (top-right frame) (add-vect
                           (edge2-frame frame)
                           (add-vect (origin-frame frame) (edge1-frame frame))))
(define (bottom-left frame) (origin-frame frame))
(define (bottom-right frame) (add-vect (origin-frame frame) (edge2-frame frame)))

(define (left-mid frame) (add-vect (origin-frame frame)
                                   (scale-vect 0.5 (edge1-frame frame))))
(define (top-mid frame) (add-vect
                         (scale-vect 0.5 (edge2-frame frame))
                         (add-vect (origin-frame frame)
                                   (edge1-frame frame))))
(define (bottom-mid frame) (add-vect (origin-frame frame)
                                     (scale-vect 0.5 (edge2-frame frame))))
(define (right-mid frame) (add-vect
                         (edge2-frame frame)
                         (add-vect (origin-frame frame)
                                   (scale-vect 0.5 (edge1-frame frame)))))

(define (top frame)  (make-segment (top-left frame) (top-right frame)))
(define (left frame) (make-segment (top-left frame) (bottom-left frame)))
(define (right frame) (make-segment (top-right frame) (bottom-right frame)))
(define (bottom frame) (make-segment (bottom-left frame) (bottom-right frame)))
</pre>
</div>
<p>
a) 画出框架的4条边,恩..套用前面定义的过程就好了
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (painter-a f)
  (segments-&gt;painter
   (list (left f) (top f) (rignt f) (bottom f))))
</pre>
</div>
<p>
b) 画出对角线..还ok
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (painter-b f)
  (segments-&gt;painter
   (list
    (make-segment (bottom-left f) (top-right f))
    (make-segment (bottom-right f) (top-left f)))))
</pre>
</div>
<p>
c) 画出各边中点连线. 于是有了上面一堆xx-mid过程..
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (painter-c f)
  (segments-&gt;paiter
   (list
    (make-segment (left-mid f) (top-mid f))
    (make-segment (top-mid f) (right-mid f))
    (make-segment (right-mid f) (bottom-mid f))
    (make-segment (bottom-mid f) (left-mid f)))))
</pre>
</div>
<p>
d) 画出wave (此处沉默1分钟&#x2026;..). 这是体力活无误了, 谁爱写谁写吧&#x2026;.ヾ(･∀･)ﾉ゛
</p>
</div>
</div>

<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63"><span class="section-number-4">2.4.7</span> 习题2.50</h4>
<div class="outline-text-4" id="text-2-4-7">
<div class="org-src-container">

<pre class="src src-scheme">(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define (flip-180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define (flip-270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64"><span class="section-number-4">2.4.8</span> 习题2.51</h4>
<div class="outline-text-4" id="text-2-4-8">
<div class="org-src-container">

<pre class="src src-scheme">(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-top
           (transform-painter painter1
                              split-point
                              (make-vect 1 0.5)
                              (make-vect 0 1)))
          (paint-below
           (transform-painter painter2
                              (make-vect 0 0)
                              (make-vect 1 0)
                              (make-vect 0 0.5))))
      (lambda (frame)
        (paint-top frame)
        (paint-bottom frame)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define (below painter1 painter2)
    (lambda (frame)
            (rotate90
                (beside
                    (rotate270
                        (flip-horiz painter1))
                    (rotate270
                        (flip-horiz painter2))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">2.4.9</span> 强健的设计语言层次</h4>
<div class="outline-text-4" id="text-2-4-9">
<p>
<code>分层设计</code> 一个复杂的系统应该通过一系列的层次构造出来,为了描述这些层次,需要使用一系列的语言.
</p>
</div>
</div>

<div id="outline-container-orgheadline66" class="outline-4">
<h4 id="orgheadline66"><span class="section-number-4">2.4.10</span> 练习2.52</h4>
<div class="outline-text-4" id="text-2-4-10">
<p>
a) 给wave加上一条线段
</p>
<div class="org-src-container">

<pre class="src src-scheme">(make-segment (left-mid f) (top-mid f));; 随便加一条线段
</pre>
</div>
<p>
b) 修改corner-split的构造模式
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1)))
            (corner (corner-split painter (- n 1))))
        (beside (below painter up)
                (below right corner)))))
</pre>
</div>
<p>
c) 修改square-limit
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (square-limit painter n)
  (let ((squarter (corner-split (flip-horiz painter) n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
</pre>
</div>
<p>
只把原来第二行的painter改成了(flip-horiz painter).
这道题目的意义大概就在于演示"在良好的分层设计下进行修改是很easy的"吧.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline72" class="outline-3">
<h3 id="orgheadline72"><span class="section-number-3">2.5</span> 符号数据</h3>
<div class="outline-text-3" id="text-2-5">
<p>
这一节将引进任意符号作为数据的功能.
</p>
</div>

<div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68"><span class="section-number-4">2.5.1</span> 引号</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
为了能够直接操作符号,我们的语言需要拥有 <b>为数据对象加引号</b> 的能力.
这样就可以将表和符号标记为应该作为 <b>数据对象</b> 看待, 而不是作为应该求值的表达式.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define a 1)
(define b 2)
(list a b) -&gt; (1 2)
(list 'a b) -&gt; (a 2)
(list 'a 'b) -&gt; (a b)
</pre>
</div>
<p>
注意, 引号只是一种将 <code>下一个完整的表达式</code> 用 (quote &lt;expression&gt;)形式包裹起来的语法糖.
</p>

<p>
基本过程 <code>eq?</code> 可以以两个符号作为参数,检查它们是否为同样的符号.
</p>
</div>
</div>

<div id="outline-container-orgheadline69" class="outline-4">
<h4 id="orgheadline69"><span class="section-number-4">2.5.2</span> 习题2.53</h4>
<div class="outline-text-4" id="text-2-5-2">
<div class="org-src-container">

<pre class="src src-scheme">(list 'a 'b 'c);Value 468: (a b c)
(list (list 'george));Value 469: ((george))
(cdr '((x1 x2) (y1 y2)));Value 473: ((y1 y2))
(cadr '((x1 x2) (y1 y2)));(y1 y2)
(pair? (car '(a short list)));#f
(menq 'red '((red shoes) (blue socks)));#f
(menq 'red '(red shoes blue socks));Value 475: (red shoes blue socks)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline70" class="outline-4">
<h4 id="orgheadline70"><span class="section-number-4">2.5.3</span> 习题2.54</h4>
<div class="outline-text-4" id="text-2-5-3">
<div class="org-src-container">

<pre class="src src-scheme">(define (equal? x y)
  (cond ((and (not (pair? x)) (not (pair? y))) (eq? x y))
        ((and (pair? x) (pair? y))
         (and (eq? (car x) (car y))
              (equal? (cdr x) (cdr y))))
        (else false)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline71" class="outline-4">
<h4 id="orgheadline71"><span class="section-number-4">2.5.4</span> 习题2.55</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
根据注释100,'a是(quote a)的语法糖, 所以:
</p>
<pre class="example">
(car ''abracadabra)
</pre>
<p>
等价于
</p>
<pre class="example">
(car '(quote abracadabra))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline78" class="outline-3">
<h3 id="orgheadline78"><span class="section-number-3">2.6</span> 实例:符号求导</h3>
<div class="outline-text-3" id="text-2-6">
</div><div id="outline-container-orgheadline73" class="outline-4">
<h4 id="orgheadline73"><span class="section-number-4">2.6.1</span> 对抽象数据的求导程序</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
对于加和乘构造起来的表达式,求导工作可以通过以下几条规约完成:
</p>
<ul class="org-ul">
<li>\(\frac{dc}{dx}=0\)</li>
<li>\(\frac{dx}{dx}=1\)</li>
<li>\(\frac{d(u+v)}{dx}=\frac{du}{dx}+\frac{dv}{dx}\)</li>
<li>\(\frac{d(uv)}{dx}=u\frac{dv}{dx}+v\frac{du}{dx}\)</li>
</ul>

<p>
假设我们已经有了一些代数运算的基本过程, 那么求导过程可以这样表达
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type -- ERIV" exp))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline74" class="outline-4">
<h4 id="orgheadline74"><span class="section-number-4">2.6.2</span> 代数表达式的表示</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
有关导数问题的数据表示:
</p>
<div class="org-src-container">

<pre class="src src-scheme">; 变量就是符号
(define (variable? x) (symbol? x))
; 两个变量相同
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
; 和式与乘式的构造函数
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
; 和式就是第一个元素为'+'的表
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
; 乘式是第一个元素为'*'的表
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
</pre>
</div>
<p>
测试求导过程:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(deriv '(+ x 3) 'x);Value 481: (+ (* x 0) (* 1 y))
(deriv '(* x y) 'x);Value 482: (+ 1 0)
</pre>
</div>
<p>
结果是对的,但是没有化简. 为了完成化简,我们需要修改构造函数的实现:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
</pre>
</div>
<p>
测试
</p>
<div class="org-src-container">

<pre class="src src-scheme">(deriv '(+ x 3) 'x);Value 1
(deriv '(* x y) 'x);Value y
(deriv '(* (* x y) (+ x 3)) 'x);Value 486: (+ (* x y) (* y (+ x 3)))
</pre>
</div>
<p>
情况好了一些,但第三个例子还是不太对,所以代数化简是非常非常复杂的问题..这里就不继续深究了..
</p>
</div>
</div>

<div id="outline-container-orgheadline75" class="outline-4">
<h4 id="orgheadline75"><span class="section-number-4">2.6.3</span> 习题2.56</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
扩展deriv, 增加对指数的求导功能.
首先定义make-exponention,exponentiation?,base,exponent:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-exponentiation a1 a2) (list '** a1 a2))
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (base x) (cadr x))
(define (exponent x) (caddr x))
</pre>
</div>
<p>
扩充deriv过程,把以下部分加入cond里:
</p>
<div class="org-src-container">

<pre class="src src-scheme">((exponentiation? exp)
         (make-product
          (make-product (exponent exp)
                        (make-exponentiation
                         (base exp)
                         (make-sum (exponent exp) -1)))
</pre>
</div>
<p>
测试:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(deriv '(** x 3) 'x);Value 490: (* 3 (** x 2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline76" class="outline-4">
<h4 id="orgheadline76"><span class="section-number-4">2.6.4</span> 习题2.57</h4>
<div class="outline-text-4" id="text-2-6-4">
<p>
扩充求导程序,使之能处理任意项的和与乘积..
设法只修改和与乘积的表示,不修改deriv.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else
         (cond
          ((not (pair? a2)) (cons '+ (append a1 (list a2))))
          (else (cons '+ (append a1 a2)))))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else
         (cond
          ((not (pair? m2)) (cons '* (append m1 (list m2))))
          (else (cons '* (append m1 m2)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline77" class="outline-4">
<h4 id="orgheadline77"><span class="section-number-4">2.6.5</span> 习题2.58</h4>
<div class="outline-text-4" id="text-2-6-5">
<p>
a).支持乘法和加法的中缀运算.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else
         (cond
          ((not (pair? a2)) (append a1 (append (list '+) (list a2))))
          (else (append a1 (append (list '+) a2)))))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else
         (cond
          ((not (pair? m2)) (append m1 (append (list '*) (list m2))))
          (else (append m1 (append (list '*) m2)))))))
(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))
</pre>
</div>
<p>
修改make-sum和make-product即可, 不需要修改deriv.
</p>

<p>
b).如果省略不必要的括号, 则必须修改deriv过程,提供处理符号优先级的功能.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline90" class="outline-3">
<h3 id="orgheadline90"><span class="section-number-3">2.7</span> 实例:集合的表示</h3>
<div class="outline-text-3" id="text-2-7">
<p>
一个集合就是一些不同对象的汇集,利用一组可以用于"集合"的操作来定义他们.这些操作是:
</p>
<ul class="org-ul">
<li>element-of-set? (谓词)</li>
<li>adjoin-set</li>
<li>union-set</li>
<li>intersection-set</li>
</ul>
</div>

<div id="outline-container-orgheadline79" class="outline-4">
<h4 id="orgheadline79"><span class="section-number-4">2.7.1</span> 集合作为未排序的表</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
定义element-of-set?
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) ())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline80" class="outline-4">
<h4 id="orgheadline80"><span class="section-number-4">2.7.2</span> 习题2.59</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
定义union
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (union set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        ((element-of-set? (car set1) set2)
         (union (cdr set1) set2))
        (else (cons (car set1) (union (cdr set1) set2)))))
</pre>
</div>
<p>
测试:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define s1 (list 1 2 3))
(define s2 (list 2 3 4))
(union s1 s2); (1 2 3 4)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">2.7.3</span> 习题2.60</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
定义可重复集合的基本操作.
首先定义最简单的adjoin,既然集合元素可重复,那么就不必判断element-of-set?了
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (adjoin-set x set) (cons x set))
</pre>
</div>

<p>
element-of-set?只用谓词不能满足后面的需求,要计算x在set中的个数
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (element-of-set? x set)
  (define (iter x set count)
    (cond ((null? set) count)
          ((equal? x (car set))
                   (iter x (cdr set) (+ count 1)))
          (else (iter x (cdr set) count))))
  (iter x set 0))
</pre>
</div>

<p>
交集有点麻烦,在cons时需要借助cons-n过程,计入某个x在set1和set2中的最小个数
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (cons-n x set n)
  (cond ((= n 0) set)
        (else (cons-n x (cons x set) (- n 1)))))

(define (intersection-set set1 set2)
  (define (iter set1 set2 result)
    (display result)
    (cond ((or (null? set1) (null? set2)) result)
          ((&gt; (element-of-set? (car set1) result) 0)
           (iter (cdr set1) set2 result))
           (else (iter (cdr set1) set2
                 (cons-n
                  (car set1)
                  result
                  (min (element-of-set? (car set1) set1)
                       (element-of-set? (car set1) set2)))))))
  (iter set1 set2 ()))
</pre>
</div>
<p>
并集
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (union set1 set2)
  (define (iter set1 set2 result)
    (cond ((null? set1) result)
          ((null? set2) set1)
          ((&gt; (element-of-set? (car set1) result)
              (element-of-set? (car set1) set1))
           (iter (cdr set1) set2 result))
          (else (iter (cdr set1) set2
                      (cons-n
                       (car set1)
                       result
                       (- (element-of-set? (car set1) set1)
                            (element-of-set? (car set1) result)))))))
  (iter set1 set2 set2))
</pre>
</div>
<p>
测试union:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(union '(a a b d d) '(a c d e f))
;Value 555: (d b a a c d e f)
</pre>
</div>
<p>
性能比不重复表差,\(2*n^2\)
</p>
</div>
</div>
<div id="outline-container-orgheadline82" class="outline-4">
<h4 id="orgheadline82"><span class="section-number-4">2.7.4</span> 集合作为排序的表</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
加速集合操作的一种方式是给集合 <code>排序</code>. 这样我们就需要某种方式来比较两个元素.
采用有序表以后,element-of-set?就不必扫描整个表了.
</p>

<p>
(下面这个过程似乎只能判断值是数值类型的集合
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((&lt; x (car set)) false)
        (else (element-of-set? x (cdr set)))))
(element-of-set 3 (list  2 3 4)) ;; Value: #t
</pre>
</div>
<p>
平均而言,这个方法需要检查的步数是\(\frac{n}{2}\).
而计算交集只需要O(n)的复杂度
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      ()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((&lt; x1 x2)
               (intersection-set (cdr set1) set2))
              ((&lt; x2 x1)
               (intersection-set set1 (cdr set2)))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline83" class="outline-4">
<h4 id="orgheadline83"><span class="section-number-4">2.7.5</span> 习题2.61</h4>
<div class="outline-text-4" id="text-2-7-5">
<div class="org-src-container">

<pre class="src src-scheme">(define (adjoin-set x set)
  (define (iter x set1 set2)
    (cond ((= x (car set2)) (append set1 set2))
          ((&lt; x (car set2)) (append set1 (append (list x (car set2)) (cdr set2))))
          (else (iter x (append set1 (list (car set2))) (cdr set2)))))
  (iter x () set))
</pre>
</div>
<p>
复杂度与二分一样,\(\frac{n}{2}\).
</p>
</div>
</div>
<div id="outline-container-orgheadline84" class="outline-4">
<h4 id="orgheadline84"><span class="section-number-4">2.7.6</span> 习题2.62</h4>
<div class="outline-text-4" id="text-2-7-6">
<div class="org-src-container">

<pre class="src src-scheme">(define (union-set set1 set2)
  (define (iter set1 set2 rst)
    (cond ((null? set1) (append rst set1))
          ((null? set2) (append rst set2))
          (else (let ((x1 (car set1)) (x2 (car set2)))
                  (cond
                   ((= x1 x2)
                    (iter (cdr set1) (cdr set2) (append rst (list x1 x2))))
                   ((&lt; x1 x2) 
                    (iter (cdr set1) set2 (append rst (list x1))))
                   ((&lt; x2 x1)
                    (iter set1 (cdr set2) (append rst (list x2)))))))))
  (iter set1 set2 ()))

(union-set '(1 2 2 4) '(2 2 3 4));Value 572: (1 2 2 2 2 3 4 4)
</pre>
</div>
<p>
最容易想到的方法当然是利用2.61的adjoin-set啦,但那样的话复杂度又变成 \(n^2\) 了..
所以这里还是利用集合有序的特性,从小到大平行遍历两个集合,这样的复杂度只有n.
</p>
</div>
</div>
<div id="outline-container-orgheadline85" class="outline-4">
<h4 id="orgheadline85"><span class="section-number-4">2.7.7</span> 集合作为二叉树</h4>
<div class="outline-text-4" id="text-2-7-7">
<p>
如果将集合安排成一棵树的形式,我们还可以得到比排序表更好的结果.
其中每个节点保存一个集合元素,称为该节点的"数据项".
</p>

<p>
将节点表示为三个元素的表:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-tree entry left right) (list enrty left right))
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
</pre>
</div>
<p>
element-of-set?和adjoin-set
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((&lt; x (entry set))
         (element-of-set? x (left-branch set)))
        ((&gt; x (entry set))
         (element-of-set? x (right-branch set)))))

(define (adjoin-set x set)
  (cond ((null? set) (make-tree x () ()))
        ((= x (entry set)) set)
        ((&lt; x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((&gt; x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline86" class="outline-4">
<h4 id="orgheadline86"><span class="section-number-4">2.7.8</span> 习题2.63</h4>
<div class="outline-text-4" id="text-2-7-8">
<ul class="org-ul">
<li>a) 两个过程对所有的树生成结果都一样, 都是左子树优先遍历.</li>
<li>b) 这两个方法的展开数相同,但第一个方法中每次展开都使用了复杂度为 \(n^2\) 的append操作,所以方法一的复杂度比方法2高的多.</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline87" class="outline-4">
<h4 id="orgheadline87"><span class="section-number-4">2.7.9</span> 习题2.64</h4>
<div class="outline-text-4" id="text-2-7-9">
<p>
首先测试结果
</p>
<div class="org-src-container">

<pre class="src src-scheme">(list-&gt;tree '(1 3 5 7 9 11))
;Value 578: (5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))
;画出来长这样:
       5
   1       9
     3   7   11
</pre>
</div>
<p>
这个算法利用二分法,递归的从叶子节点开始产生平衡树.上面这个树的计算过程是:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(1 3 5 7 9 11) 
;left-length: 2
(1 3) 5 (7 9 11) 
;left-of-left-tree: 0, left-of-right-tree: 1
(() 1 (3)) 5 ((7) 9 (11))
</pre>
</div>
<p>
复杂度:对于每个节点,上述算法只是进行make-tree,也没有额外的遍历, 所以复杂度是 \(O(n)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline88" class="outline-4">
<h4 id="orgheadline88"><span class="section-number-4">2.7.10</span> 习题2.65</h4>
<div class="outline-text-4" id="text-2-7-10">
<p>
并集先利用tree-&gt;list把一个tree转化成list, 然后利用前面的adjoin-set方法把元素逐个插入第二个tree中.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (union-set-tree tree1 tree2)
  (let ((list1 (tree-&gt;list tree1)))
    (define (adjoin-list-to-tree list tree)
      (cond ((null? list) tree)
            (else
             (adjoin-list-to-tree (cdr list)
                                  (adjoin-set (car list) tree)))))
    (list-&gt;tree (adjoin-list-to-tree list1 tree2))))
</pre>
</div>
<p>
交集直接利用tree-&gt;list转化成list以后append,再利用list-&gt;tree转化回来
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (intersection-set-tree tree1 tree2)
  (list-&gt;tree (intersection-set
               (tree-&gt;list tree1)
               (tree-&gt;list tree2))))
</pre>
</div>
<p>
测试
</p>
<div class="org-src-container">

<pre class="src src-scheme">(union-set-tree (list-&gt;tree '(1 3 5)) (list-&gt;tree '(2 4)))
;Value 613: ((1 () ()) (2 () ()) ((4 (3 () ()) (5 () ())) () ()))

(intersection-set-tree (list-&gt;tree '(1 3 5)) (list-&gt;tree '(1 3 5 9 7 11)))
;Value 612: (3 (1 () ()) (5 () ()))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline89" class="outline-4">
<h4 id="orgheadline89"><span class="section-number-4">2.7.11</span> 习题2.66</h4>
<div class="outline-text-4" id="text-2-7-11">
<p>
实现对已根据key排序的二叉树查找. 
前面定义的entry只有value,所以我们需要构造一个key-value结构的节点及key和value的读取过程.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-entry key value) (cons key value))
(define (key entry) (car entry))
(define (value entry) (cdr entry))
</pre>
</div>
<p>
实现普通的二叉树查找:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (loopup x tree)
  (cond ((null? tree) false)
        ((= x (key (entry tree)))
         (value (entry tree)))
        ((&lt; x (key (entry tree))) 
         (loopup x (left-branch tree)))
        ((&gt; x (key (entry tree))) 
         (loopup x (right-branch tree)))))
</pre>
</div>
<p>
构造测试数据测试:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define test-tree (list-&gt;tree (list
                               (make-entry 1 "aa")
                               (make-entry 2 "bb")
                               (make-entry 3 "cc")
                               (make-entry 4 "dd")
                               (make-entry 5 "ee")
                               )))
(loopup 3 test-tree) ;Value: "cc"
(loopup 5 test-tree) ;Value: "dd"
(loopup 1 test-tree) ;Value: "aa"
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline97" class="outline-3">
<h3 id="orgheadline97"><span class="section-number-3">2.8</span> 实例:Huffman编码树</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Huffman编码书树简单来说是用于实现 <b>无重复前缀变长编码</b> 的树形结构.
</p>
</div>

<div id="outline-container-orgheadline91" class="outline-4">
<h4 id="orgheadline91"><span class="section-number-4">2.8.1</span> 习题2.67</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
要把本节代码全敲一遍才能算出来的题目&#x2026;.累死宝宝了. 代码太长不贴了, 最终答案是:
</p>
<pre class="example">
(a d a b b c a)
</pre>
</div>
</div>

<div id="outline-container-orgheadline92" class="outline-4">
<h4 id="orgheadline92"><span class="section-number-4">2.8.2</span> 习题2.68</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
实现加密算法. 步骤大概是从树根开始查找,如果元素在节点左字树的symbols中,则向结果中添加0,
然后继续在左子树中查找, 右子树同理. 如果遇到叶子节点则说明该字符已经加密完成, 
而后取下一个字符从根节点开始重新查找. 要实现一个判断节点是否在symbols的过程,并注意处理节点是叶子的情况.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (symbol-in-tree? symbol tree)
  (cond ((leaf? tree) (eq? symbol (symbol-leaf tree)))
        (else (memq symbol (symbols tree)))))

(define (encode-symbol message tree)
  (define (encode-iter message subtree result)
    (cond ((null? message) result)
          ((leaf? subtree) (encode-iter (cdr message) tree result))
          (else (let ((left (left-branch subtree))
                 (right (right-branch subtree)))
             (cond ((symbol-in-tree? (car message) left)
                    (encode-iter  message left (cons '0 result)))
                   ((symbol-in-tree? (car message) right)
                    (encode-iter  message right (cons '1 result)))
                   (else (error "sambol not in the tree"))
                   )))))
  (encode-iter message tree ()))
</pre>
</div>
<p>
用上一题的加密结果来测试, 答案正确.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define sample-message '(a d a b b c a))
(encode-symbol sample-message sample-tree)
;Value 643: (0 1 1 1 0 1 0 1 0 0 1 1 0)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline93" class="outline-4">
<h4 id="orgheadline93"><span class="section-number-4">2.8.3</span> 习题2.69</h4>
<div class="outline-text-4" id="text-2-8-3">
<p>
这道题目颇费了一些时间&#x2026;.
关键的技巧是利用有序性, 反复归并前两个元素, 并利用adjoin-set将归并后的节点插入回节点序列.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (successive-merge pairs)
  (cond ((= 1 (length pairs)) pairs)
        (else
         (successive-merge
          (adjoin-set
           (make-code-tree (car pairs) (cadr pairs))
           (cddr pairs))))))
;; test
(successive-merge (make-leaf-set (list '(A 4) '(B 2) '(C 1) '(D 1))))
;Value 649: (((leaf a 4) ((leaf b 2) ((leaf d 1) (leaf c 1) (d c) 2) (b d c) 4) (a b d c) 8))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline94" class="outline-4">
<h4 id="orgheadline94"><span class="section-number-4">2.8.4</span> 习题2.70</h4>
<div class="outline-text-4" id="text-2-8-4">
<div class="org-src-container">

<pre class="src src-scheme">(define sing-pairs (list '(a 2) '(na 16) '(boom 1) '(sha 3) '(get 2) '(yip 9) '(job 2) '(wah 1)))
(define sing-tree (car (successive-merge (make-leaf-set sing-pairs))))
(encode-symbol '(Get a job) sing-tree)
; (0 0 0 0 0 0 0 0 0 1 1 1)
(encode-symbol '(Sha na na na na na na na na) sing-tree)
; (0 1 1 1 1 0 0 1 1 1 1 1 1 1)
(encode-symbol '(Get a job) sing-tree)
; (0 0 0 0 0 0 0 0 0 1 1 1)
(encode-symbol '(Sha na na na na na na na na) sing-tree)
; (0 1 1 1 1 0 0 1 1 1 1 1 1 1)
(encode-symbol '(Wah yip yip yip yip yip yip yip yip yip) sing-tree)
; (0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1)
(encode-symbol '(Sha boom) sing-tree)
; (1 1 0 1 1 0 1 1 1)
</pre>
</div>
<p>
共需要84个二进制位. 如果用定长编码,为8个单词的编码,每个单词需要3个二进制位, 
总共需要36*3=108个二进制位.
</p>
</div>
</div>
<div id="outline-container-orgheadline95" class="outline-4">
<h4 id="orgheadline95"><span class="section-number-4">2.8.5</span> 习题2.71</h4>
<div class="outline-text-4" id="text-2-8-5">
<p>
n=5时,频度分别是1,2,4,8,16,树长这样:
</p>
<div class="org-src-container">

<pre class="src src-scheme">                    (a,b,c,d,e) 31
               (a,b,c,d)15     e 16
         (a,b,c) 7      d 8
   (a,b)3        c 4
a 1      b 2
</pre>
</div>
<p>
频度最高的符号是e,它是根节点的右子树,编码需要1个二进制位.最不频繁的符号是a,位于树的第(n-1)层,需要4个二进制位.
推广到一般的树,最频繁的符号需要1位,最不频繁的符号需要(n-1)位.
</p>
</div>
</div>
<div id="outline-container-orgheadline96" class="outline-4">
<h4 id="orgheadline96"><span class="section-number-4">2.8.6</span> 习题2.72</h4>
<div class="outline-text-4" id="text-2-8-6">
<p>
对编码最频繁的符号来说,只需进行2次symbol-in-tree(因为首先计算左子数)即可命中,复杂度是n.
对编码最不频繁的符号来说,需要进行n-1次symbol-in-tree才能命中,
由于查找表逐层递减,总共需要查找 $1+2+..(n-1)=/fracn<sup>2</sup>/2$次,复杂度是O(n<sup>2</sup>).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline110" class="outline-2">
<h2 id="orgheadline110"><span class="section-number-2">3</span> 抽象数据的多重表示</h2>
<div class="outline-text-2" id="text-3">
<p>
有时候,对于一个数据对象存在多种不同的表示方式,比如复数就可以表示为两种等价的形式:直角坐标想形式和极坐标形式.
</p>

<p>
这一节我们将学习如何处理数据,使它们可能在一个程序的不同部分中采用不同的表示方式.
更甚者,我们需要建立抽象屏障去隔离这些不同的设计选择.
</p>

<p>
实现这种设计的关键是使用 <code>带有类型标识的数据对象</code>, 也就是让数据对象包含着它们应该如何处理的明确的信息.
</p>
</div>

<div id="outline-container-orgheadline99" class="outline-3">
<h3 id="orgheadline99"><span class="section-number-3">3.1</span> 复数的表示</h3>
<div class="outline-text-3" id="text-3-1">
<p>
沿用在2.1.1节设计有理数包时所采用的同样的数据抽象策略,假定复数运算的实现都包括以下4个选择函数:
</p>
<ul class="org-ul">
<li>real-part</li>
<li>imag-part</li>
<li>magnitude</li>
<li>angle</li>
</ul>

<p>
以及两个构造过程
</p>
<ul class="org-ul">
<li>make-from-real-imag</li>
<li>make-from-mag-ang</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-3">
<h3 id="orgheadline100"><span class="section-number-3">3.2</span> 带标志的数据</h3>
<div class="outline-text-3" id="text-3-2">
<p>
由选择函数和构造函数形成的抽象屏障,使我们可以把为自己所用的数据对象选择具体表示形式的事情尽量向后推,而且可以保持系统的灵活性.
</p>

<p>
为了能对带标志的数据进行各种操作,我们将假定有过程 <code>type-tag</code> 和 <code>contents</code> ,它们分别从数据对象中提取出标志和实际内容.
还要有一个过程 <code>attach-tag</code> ,用来生成带标志的数据对象.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "bad tagged datum -- TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "bad tagged datum -- CONTENTS" datum)))

(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))

(define (polar? z)
  (eq? (type-tag z) 'polar))
</pre>
</div>
<p>
然后使用不同后缀标志不同过程的名字
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))

(define (real-part-rectangular z) (car z))
</pre>
</div>
<p>
然后用switch-case来实现通用过程real-part.. (为什么感觉switch-case搓搓的..
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unkown type -- REAL_PART" z))))
</pre>
</div>
<p>
这样,实现复数运算时,我们依然可以采用如下形式,因为选择函数是通用的.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
</pre>
</div>

<p>
当通用类型选择polar类型的复数时,它会剥去标志, 只将内容传递给后面的代码. 
而当构建一个复数时, 又会加上标志.
这种 <code>剥去和加上标志</code> 的规范方式可以成为一种重要的组织策略.
</p>
</div>
</div>

<div id="outline-container-orgheadline106" class="outline-3">
<h3 id="orgheadline106"><span class="section-number-3">3.3</span> 数据导向的程序设计和可加性</h3>
<div class="outline-text-3" id="text-3-3">
<p>
上一节的实现有一些缺点(就是我吐槽的),switch-case的实现要求通用过程必须知道如何操作每一类数据.
另外,还要保证系统中处理数据的过程不重名.
基于这两点原因,我们说上面的实现不具备 <code>可加性</code>
</p>

<p>
这一节要进一步将系统设计模块化, 我们叫它 <code>数据导向的程序设计</code>
</p>

<p>
下面节选一些代码简要说明一下&#x2026;注意put和get是超前的内容,在3.3.3节中会讲到.
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (install-rectangular-package)
  ;;internal procedures
  (define (real-part z) (car z))
  ;;interface rest of the system
  (define (tag x) (attach-tag 'rectangular z))
  (put 'real-part '(rectangular) real-part))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
           "No mathod for these type -- APPLY-GENERIC"
           (list op type-tags))))))

(define (real-part z) (apply-generic 'real-part z))
</pre>
</div>
<p>
大意就是把数据相关的过程打包存放在一张表里, 以数据类型为key. 用的时候一顿找, 取出相应的过程应用到数据类型.
</p>

<p>
补充:不实现get和put方法的话后面的习题都无法继续了..所以在这里贴一下代码,测试可用
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define local-table (list '*table*))
(define (assoc key records)
  (cond ((null? records)
         #f)
        ((equal? key (caar records))
         (car records))
        (else
         (assoc key (cdr records)))))
(define (get key-1 key-2)
  (let ((subtable (assoc key-1 (cdr local-table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              #f))
        #f)))
(define (put key-1 key-2 value)
  (let ((subtable (assoc key-1 (cdr local-table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! local-table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr local-table)))))
  'ok)
</pre>
</div>
</div>

<div id="outline-container-orgheadline101" class="outline-4">
<h4 id="orgheadline101"><span class="section-number-4">3.3.1</span> 习题2.73</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>a) 因为number?和same-value这两种逻辑无法用运算符来描述,也就无法放在索引表中.</li>
<li>b) 写出针对和式与积式的求导过程</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
;; 求导过程
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        (else
         ((get 'deriv (operator exp)) (operands exp) var))))
;; 安装内部过程
(define (install-deriv-package)
  (define (deriv-sum exp var)
    (make-sum (deriv (car exp) var)
              (deriv (cadr exp) var)))
  (define (deriv-product exp var)
    (make-sum
     (make-product (car exp)
                   (deriv (cadr exp) var))
     (make-product (deriv (car exp) var)
                   (cadr exp))))
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product))
(install-deriv-package)
;; 测试
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
</pre>
</div>
<ul class="org-ul">
<li><p>
c) 把乘幂添加到上述系统中
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (install-deriv-package)
  (define (deriv-sum exp var)
    (make-sum (deriv (car exp) var)
              (deriv (cadr exp) var)))
  (define (deriv-product exp var)
    (make-sum
     (make-product (car exp)
                   (deriv (cadr exp) var))
     (make-product (deriv (car exp) var)
                   (cadr exp))))
  (define (exponentiation exp var)
    (make-product (cadr exp)
                  (make-exponentiation
                   (car exp)
                   (make-sum (cadr exp) -1))))
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  (put 'deriv '** exponentiation))
(install-deriv-package)
;; test
(deriv '(** x 3) 'x)
; Value: (* 3 (** x 2))
</pre>
</div></li>
<li>d) 把</li>
</ul>
<pre class="example">
(put 'deriv 'operator operation)
</pre>
<p>
改成
</p>
<pre class="example">
(put 'operator 'deriv  operation)
</pre>
</div>
</div>

<div id="outline-container-orgheadline102" class="outline-4">
<h4 id="orgheadline102"><span class="section-number-4">3.3.2</span> 习题2.74</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
首先需要定义两个方法作为工具,比起前面的put和get,它们多了一个table参数
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (get-tb table key-1 key-2 )
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              #f))
        #f)))
(define (put-tb table key-1 key-2 value)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
</pre>
</div>
<ul class="org-ul">
<li>a)</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (employee name)
  (define rst (list '*table*))
  (put-tb rst name 'address 'my-address)
  (put-tb rst name 'salary '999)
  rst)

(define (load-offices)
  (define office-table (list '*table))
  (put-tb office-table 'office-1 'name1 (employee 'name1))
  (put-tb office-table 'office-2 'name2 (employee 'name2))
  (put-tb office-table 'office-2 'name3 (employee 'name3))
  (put-tb office-table 'office-3 'name2 (employee 'name2))
  office-table)

(define offices-record (load-offices))
</pre>
</div>

<ul class="org-ul">
<li>b) 普通的查询</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (get-record office name)
  (get-tb offices-record office name))

(define (get-salary office name)
  (define employee (get-tb offices-record office name))
  (if (not employee)
      (error "CANNOT FIND THE EMPLOYEE!")
      (get-tb employee name 'salary)))

(get-record 'office-2 'name2)
(get-salary 'office-1 'name2)
</pre>
</div>

<ul class="org-ul">
<li>c) 稍微复杂的查询</li>
</ul>
<div class="org-src-container">

<pre class="src src-scheme">(define (find-employee-record name)
  (define (iter table name result)
    (if (null? table)
        result
        (let ((subtable (car table)))
          (if (null? subtable)
              result
              (let ((record (assoc name (cddr (cadr subtable)))))
                (if record
                    (iter (cdr table) name (cons result record)
                    (iter (cdr table) name result)))))))
    (iter (cdr offices-record) name '()))

  (find-employee-record 'name3)
</pre>
</div>
<ul class="org-ul">
<li>d) 在前面load-office方法中添加新条目即可</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline103" class="outline-4">
<h4 id="orgheadline103"><span class="section-number-4">3.3.3</span> 消息传递</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
另一种实现智能数据对象的策略是将每一个数据对象表示为一个过程,它以操作的名字作为输入,能够去执行特定的操作.
</p>

<p>
我们叫它 <code>基于操作名的分派</code>
</p>

<p>
按照这种思路实现复数(我简化过了..意思传达到即可..
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y))))

(define (apply-generic op arg) (arg op))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline104" class="outline-4">
<h4 id="orgheadline104"><span class="section-number-4">3.3.4</span> 习题2.75</h4>
<div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">

<pre class="src src-scheme">(define (make-from-mag-ang x y)
  (define (dispatch op)
    (cond ((eq? op 'magnitude) x)
          ((eq? op 'angle) y)
          ((eq? op 'real-part) (* x (sin y)))
          ((eq? op 'imag-part) (* x (cons y)))
          (else
           (error "Unknown op -- MAKE FROM MAG ANG" op))))
  dispatch)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline105" class="outline-4">
<h4 id="orgheadline105"><span class="section-number-4">3.3.5</span> 习题2.76</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
基于类型的分派适合需要经常加入新类型的系统,当有变化时向系统中添加一个package即可.
</p>

<p>
而基于操作名的分派适合经常加入新操作的系统. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline109" class="outline-3">
<h3 id="orgheadline109"><span class="section-number-3">3.4</span> 带有通用型操作的系统</h3>
<div class="outline-text-3" id="text-3-4">
<p>
上一节教我们定义能够在不同表示上的通用运算包, 这一节教我们定义针对不同参数种类的通用型操作.
</p>
</div>

<div id="outline-container-orgheadline107" class="outline-4">
<h4 id="orgheadline107"><span class="section-number-4">3.4.1</span> 通用型算术运算</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
书本上示例繁杂, 这里仅用add方法来说明吧
</p>

<p>
首先,通用型算术过程的定义如下:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (add x y) (apply-generic 'add x y))
</pre>
</div>

<p>
然后安装各种包..
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
      (lambda (x y) (tag (+ x y))))
   'done)
</pre>
</div>

<p>
可以看到,通用型的算术运算是利用内部过程+两层tag来实现的
</p>
</div>
</div>

<div id="outline-container-orgheadline108" class="outline-4">
<h4 id="orgheadline108"><span class="section-number-4">3.4.2</span> 习题2.77</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
'complex包中并不存在'magnitude操作,所以返回错误
</p>

<p>
apply-generic被调用了3次. 过程如下
</p>
<div class="org-src-container">

<pre class="src src-scheme">(magnitude z)
(apply-generic 'magnitude z)
;-&gt; (complex)
(get 'magnitude (complex))
(apply magnitude z)
(apply magnitude (map contents (list z)))
(magnitude '(rectangular 3 4))
(apply-generic 'magnitude '(rectangular 3 . 4))
(map type-tag (list '(rectangular 3 . 4)))                      ; =&gt; '(rectangular)
(get 'magnitude '(rectangular))                                 ; =&gt; magnitude  ; 这个 magnitude 是定义于 rectangular 包中的 magnitude
(apply magnitude (map contents (list '(rectangular 3 . 4))))    ; =&gt; (apply magnitude '((3 . 4)))
(magnitude '(3 . 4))
(sqrt (+ (square (real-part '(3 . 4)))
         (square (imag-part '(3 . 4)))))
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/04/05/sicp-ch2-构造数据抽象/</guid>
    </item>
    <item>
      <title>Game Programming Patterns Reading Note</title>
      <link>http://tsubasawp.github.io/blog/2016/05/17/game-programming-patterns-reading-note</link>
      <description><![CDATA[reading note]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/05/17/game-programming-patterns-reading-note</guid>
    </item>
    <item>
      <title>GPU Points</title>
      <link>http://tsubasawp.github.io/blog/2016/02/02/gpu-overview</link>
      <description><![CDATA[一些关于GPU的知识点,内容大部分源自RTR.]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/02/02/gpu-overview</guid>
    </item>
    <item>
      <title>[阅记] 解忧杂货铺 - 来自上天的祈祷</title>
      <link>http://tsubasawp.github.io/blog/2016/01/30/[阅记]-解忧杂货铺---来自上天的祈祷/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>[阅记] 解忧杂货铺 - 来自上天的祈祷</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 前言</a></li>
<li><a href="#orgheadline16">2. 时间线</a>
<ul>
<li><a href="#orgheadline2">2.1. - 1968</a></li>
<li><a href="#orgheadline3">2.2. - 1969</a></li>
<li><a href="#orgheadline4">2.3. - 1970</a></li>
<li><a href="#orgheadline5">2.4. - 1978</a></li>
<li><a href="#orgheadline9">2.5. - 1979</a></li>
<li><a href="#orgheadline14">2.6. - 1980</a></li>
<li><a href="#orgheadline15">2.7. - 2012</a></li>
</ul>
</li>
<li><a href="#orgheadline21">3. 反思</a></li>
<li><a href="#orgheadline22">4. 最后</a></li>
</ul>
</div>
</div>
<p>
[内含微量剧透]
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
解忧杂货铺有点像微小说集, 由几个治愈系小故事串联而成, 跨越时间和空间, 被大叔用脑洞联系在了一起.
</p>

<p>
这是我读到的东野圭吾的第4部作品, 可能因为第一部&lt;嫌疑人x的献身&gt;让人感到太震(meng)撼(bi), 所以后来看的几本带来的惊喜感没有那么强烈. 
这不是一部推理小说, 然而书中的角角落落都布满可疑的线索, 让人不得不在意. 当脑中充满混乱的线索, 毫无头绪时, 我不幸的迎来了看起来有点哲学意味的结局.
当时十分失落, 随后就关掉手机睡觉了. 但那些奇怪的线索似乎不甘心就这样被遗忘掉, 总是在脑中盘旋, 早上醒来后依旧满脑这个故事.
于是我在心里按照小说里的时间线粗略的梳理, 越想越乱, 这个故事里似乎充满了矛盾, 又没有明确的谜题. 圭吾大叔你是要闹哪样啊!
</p>

<p>
思前想后,感觉首先需要解决的问题有2个:
</p>
<ul class="org-ul">
<li>这个平行空间的设定到底是怎样的? 为什么在同一夜中, 过去与现在的时间跨度不同?</li>
<li>为什么浪矢可以预知自己的祭日?</li>
</ul>

<p>
由于智商低, 只好求助于纸笔. 我又从头翻阅小说梳理了一下时间线, 希望能得到一些启示:
</p>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="orgheadline16"><span class="section-number-2">2</span> 时间线</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">2.1</span> - 1968</h3>
<div class="outline-text-3" id="text-2-1">
<p>
贵之母亲去世
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.2</span> - 1969</h3>
<div class="outline-text-3" id="text-2-2">
<p>
皆月晓子去世
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">2.3</span> - 1970</h3>
<div class="outline-text-3" id="text-2-3">
<p>
孤独的浪矢开始解答孩子们的疑问,心情开始变好
</p>
<ul class="org-ul">
<li>回答了询问怎样考100分的孩子, 百分小毛头</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">2.4</span> - 1978</h3>
<div class="outline-text-3" id="text-2-4">
<p>
贵之发现手表时间异常, 杂货铺内时间流逝变快
</p>

<p>
浪矢回答了绿河的咨询
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">2.5</span> - 1979</h3>
<div class="outline-text-3" id="text-2-5">
</div><ol class="org-ol"><li><a id="orgheadline6"></a>1979.6<br  /><div class="outline-text-5" id="text-2-5-0-1">
<p>
浪矢看到报道:绿河在开车是因贫血昏迷并坠河, 死前救了副驾上1岁左右的女儿
</p>

<p>
贵之听说父亲关店回家看望时,门锁着
</p>

<p>
杂货铺关闭
</p>

<p>
浪矢开始梦到自己的灵魂能看到几十年后杂货店中发生的事
</p>
</div></li>

<li><a id="orgheadline7"></a>1979.9.13<br  /><div class="outline-text-5" id="text-2-5-0-2">
<p>
浪矢写了遗书, 明确知道自己会在9.13号这天去世
</p>

<p>
浪矢搬回杂货店过了一夜, 并收到了来自未来的来信
</p>
<ul class="org-ul">
<li>百分小毛头</li>
<li>川边绿的女儿, 见证孤儿院火灾, 后成为歌手女的经济人</li>
<li>保罗的感谢信</li>
<li>一张白纸</li>
</ul>
</div></li>

<li><a id="orgheadline8"></a>1979.11<br  /><div class="outline-text-5" id="text-2-5-0-3">
<p>
月兔投出了咨询信, 2012年的小偷三人组收到并回了信
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">2.6</span> - 1980</h3>
<div class="outline-text-3" id="text-2-6">
</div><ol class="org-ol"><li><a id="orgheadline10"></a>1980.7<br  /><div class="outline-text-5" id="text-2-6-0-1">
<p>
鱼店音乐人写信咨询, 三人组回复
</p>
</div></li>

<li><a id="orgheadline11"></a>1980.9.13<br  /><div class="outline-text-5" id="text-2-6-0-2">
<p>
浪矢去世
</p>
</div></li>

<li><a id="orgheadline12"></a>1980.10<br  /><div class="outline-text-5" id="text-2-6-0-3">
<p>
迷途的小狗(晴美)写信咨询, 三人组回复
</p>
</div></li>

<li><a id="orgheadline13"></a>1988.12.24<br  /><div class="outline-text-5" id="text-2-6-0-4">
<p>
丸光园发生火灾, 鱼店音乐人为了救人丧命. 
</p>

<p>
这场火灾影响到本书中几乎所有人物.
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">2.7</span> - 2012</h3>
<div class="outline-text-3" id="text-2-7">
<p>
在约定的9月13日, 小偷三人组在0点左右抢劫了晴美, 抢到了她装有感谢信的手包. 2:30分到达杂货店, 在6:00离开, 期间为三个人解答过烦恼. 
</p>

<p>
三人组在离开之前, 把一张白纸投入了门口信箱中, 并得到来自过去的浪矢的回复.
</p>

<p>
三人组在偷来的手包中 发现了晴美写给他们的感谢信
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline21" class="outline-2">
<h2 id="orgheadline21"><span class="section-number-2">3</span> 反思</h2>
<div class="outline-text-2" id="text-3">
</div><ol class="org-ol"><li><a id="orgheadline17"></a>第一个问题: 时间线<br  /><div class="outline-text-5" id="text-3-0-0-1">
<p>
仔细梳理后, 不得不承认, 杂货铺中存在着两条不同的时间线, 而这两条线的关系看起来有点牵强&#x2026;
</p>

<p>
第一条: 1979年9月13日0点-6点, 浪矢爷爷可以收到来自2012年9月13日0点-6点间的来信, 这也能解释为何三人组最后寄出的白纸可以被收到.
</p>

<p>
第二条: 2012年9月13日0点-6点, 三人组可以与1979年9月-1980年10月这一年左右的时间联通.
</p>
</div></li>

<li><a id="orgheadline18"></a>第二个问题: 祭日<br  /><div class="outline-text-5" id="text-3-0-0-2">
<p>
反复看小说与时间表, 只能找到这样的解释: 浪矢在得知绿川死后, 并生病住院的期间, 反复做着预知梦. 他在梦中得知33年后杂货铺会连通现在与过去, 并以为自己会在1979年9月13号这天去世, 所以留了信给贵之,并要求这一天晚上去杂货店中收信.
</p>

<p>
[这个解释我并不满意, 为什么浪矢爷爷可准确的在1年后(1980)的这一天去世? 为什么公告上写33周年祭日, 而不是实际的22周年?]
</p>
</div></li>

<li><a id="orgheadline19"></a>没有用到的线索<br  /><div class="outline-text-5" id="text-3-0-0-3">
<ul class="org-ul">
<li>红豆包: 在1978年贵之的家中出现过一次,浪矢把它放在了佛龛上. 1979年浪矢病中出现过一次,浪矢没有在意.</li>

<li>贵之的手表: 1978年左右这个手表开始出现变慢的现象, 本以为从此时开始, 贵之的家中(既杂货铺)时间流逝开始变得异常. 但最后贵之的孙子接手这块表时, 表依旧每小时慢5分钟, 所以这个线索大概是故布疑阵吧.</li>
</ul>
</div></li>

<li><a id="orgheadline20"></a>关于晓子<br  /><div class="outline-text-5" id="text-3-0-0-4">
<p>
晓子临终前说, "我会在天上为大家的幸福祈祷".
</p>

<p>
这里几乎所有人物都与孤儿院产生过联系, 他们最后都过得还不错(除了歌手), 不知扭曲时空的力量是不是晓子的杰作.
</p>

<p>
于是末章标题总结了这整本书: 来自上天的祈祷
</p>
</div></li></ol>
</div>


<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22"><span class="section-number-2">4</span> 最后</h2>
<div class="outline-text-2" id="text-4">
<p>
这本小说的主要目的是说故事, 并不是推理. 前面碎碎念了一大坨没用的推导, 也该说说故事本身了. 
5个小故事形态各异, 主人公们各自背负着无奈的命运, 最后都直接或间接的通过杂货铺得到启示, 走向了各自的人生之路. 
</p>

<p>
我在微信阅读读到的这本书(没办法最近它太火了, 天天在眼前晃), 这个app可以在书中看到其他人对字句的短评. 每个故事中都有人热情的评论, 大家都能找到各自的共鸣点.  
我自己则是在歌手妹子在舞台上唱起&lt;重生&gt;时泪蹦了, 完全沉浸在了鱼店歌手的挣扎中, 这就是大部分有梦想没天赋的普通人的命运吧.
</p>

<p>
好的文学作品可以让各种人得到启发, 这本小说做到了 ( 虽然更喜欢作者的推理 :p
</p>



<p>
最后, 但愿这些胡乱猜测没有过分歪曲圭吾大叔的本意 (￣.￣) 
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-07-28</pubDate>
      <guid>http://tsubasawp.github.io/blog/2016/01/30/[阅记]-解忧杂货铺---来自上天的祈祷/</guid>
    </item>
  </channel>
</rss>