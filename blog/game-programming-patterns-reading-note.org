#+TITLE:       Game Programming Patterns Reading Note
#+AUTHOR:      Tsubasa
#+EMAIL:       Tsubasa@Tsubasas-MacBook-Pro.local
#+DATE:        2016-05-17 Tue
#+URI:         /blog/%y/%m/%d/game-programming-patterns-reading-note
#+KEYWORDS:    reading note
#+TAGS:        reading note
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: reading note

* Architecture, Performance, and Games
这一节不多说了,老生常谈, 在速度和优雅间权衡. 最后有句话说的不错:
- When we think of elegant solutions, what we often have in mind is a general one: a small bit of logic that still correctly covers a large space of use cases.
作为仔细阅读Intro的回报,作者给出几个'忠告':
- 如果不是确定非常需要,不轻易进行模块化和解耦.
- 随时考虑代码结构的性能,而尽量把底层优化推后.
- 尽量快的探索游戏设计的可能性,但依旧要时时注意代码结构,积累太多垃圾代码就不好玩了.
- 重构不必过于追求完美
- 如果你觉得干这些没意思就别干了吧...

* Sequencing Patterns
乍一看标题还以为是Sequence Queue之类的东西,我真是too young..

需要one by one处理一坨东西的结构都可以称为sequencing patterns. 这里介绍三种.

** Double buffer

*** Intent
使得一系列有序操作得以迅速且平滑的进行.

*** Intro
双缓冲应用比较广的场景是在Rendering阶段:

渲染好的像素被输出到frame buffer, 然后buffer中的内容会被直接输出到显示设备.
如果只有一个buffer, 会出现边更新边输出的状况, 显示设备上画面可能会出现撕裂. 双缓冲和三缓冲等技术是为了避免这个问题.
双缓冲顾名思义, 使用两个buffer来储存渲染画面. 分别为 back buffer 和 front buffer. 当front buffer被输出时, 下一帧的数据被放在back buffer中. front输出完毕后交换两个buffer.


*** When to use
- 需要频繁的改变一些状态
- 需要在改变时访问状态
- 状态改变在进行时禁止被代码访问
- 而代码不希望等到改变结束才能访问

*** Caveats
- 交换操作必须是原子的
- 增加了内存占用

** Game loop

*** Intent
将游戏速度与用户输入及处理器速度解耦.

*** The pattern

*** When to use
游戏引擎自带 :)


** Update Method

 Each time you add two floating point numbers, 
the answer you get back can be a bit off

