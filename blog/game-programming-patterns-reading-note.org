#+TITLE:       Game Programming Patterns Reading Note
#+AUTHOR:      Tsubasa
#+EMAIL:       Tsubasa@Tsubasas-MacBook-Pro.local
#+DATE:        2016-05-17 Tue
#+URI:         /blog/%y/%m/%d/game-programming-patterns-reading-note
#+KEYWORDS:    reading note
#+TAGS:        reading note
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: reading note

其实这是篇读书笔记啦(捂脸...

对这个话题感兴趣又愿意花时间了解的同学直接移步这里吧
http://gameprogrammingpatterns.com/contents.html

作者文笔风骚,干货满满,绝对五星好评.


* 概览: 结构,性能以及游戏.
"每当提到所谓 *优雅* 的方案,我们想要的往往是用尽量少的代码驱动尽量多的用例."

顾名思义,这篇文章将要介绍一些在游戏设计中常用的模式.
在展开之前先给大家几个tip:
- 如果不是确定非常需要,不轻易进行模块化和解耦 (毕竟都是有代价的嘛..
- 尽快响应策划大神们的需求,但依旧要时时注意代码结构,积累太多垃圾代码就不好玩了.
- 随时考虑代码结构的性能,而尽量把底层优化推后.
- 重构不必过于追求完美 (处女座退散

* 一些通用设计模式
下面这几个模式大家都比较熟,也并不仅被应用于游戏开发中,在这里就不展开介绍了.
- 命令模式(Command)
- 享元模式(Flyweight) 
  容我吐个槽,享元模式这翻译真是太不幽默了
- 观察者模式(Observer)
- 原型(Prototype)
- 单例(Singleton)
- 状态(State)

* 有序的模式 (Sequencing Patterns)
好难翻译
乍一看标题还以为是Sequence Queue之类的东西,我真是too young..
需要one by one处理一坨东西的结构都可以称为sequencing patterns. 这里介绍三种.

** 双缓存 Double buffer

*** Intent
使得一系列有序操作得以迅速且平滑的进行.

*** Intro
双缓冲应用比较广的场景是在Rendering阶段:

渲染好的像素被输出到frame buffer, 然后buffer中的内容会被直接输出到显示设备.
如果只有一个buffer, 会出现边更新边输出的状况, 显示设备上画面可能会出现撕裂. 双缓冲和三缓冲等技术是为了避免这个问题.
双缓冲顾名思义, 使用两个buffer来储存渲染画面. 分别为 back buffer 和 front buffer. 当front buffer被输出时, 下一帧的数据被放在back buffer中. front输出完毕后交换两个buffer.


*** When to use
- 需要频繁的改变一些状态
- 需要在改变时访问状态
- 状态改变在进行时禁止被代码访问
- 而代码不希望等到改变结束才能访问

*** Caveats
- 交换操作必须是原子的
- 增加了内存占用

** 游戏循环 Game loop

*** Intent
将游戏速度与用户输入及处理器速度解耦.

*** The pattern

*** When to use
游戏引擎自带 :)


** Update 方法

 Each time you add two floating point numbers, 
the answer you get back can be a bit off

