#+TITLE:       Game Programming Patterns Reading Note
#+AUTHOR:      Tsubasa
#+EMAIL:       Tsubasa@Tsubasas-MacBook-Pro.local
#+DATE:        2016-05-17 Tue
#+URI:         /blog/%y/%m/%d/game-programming-patterns-reading-note
#+KEYWORDS:    reading note
#+TAGS:        reading note
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: reading note

其实这是篇读书笔记(捂脸...

对这个话题感兴趣又愿意花时间了解的同学直接移步这里吧
http://gameprogrammingpatterns.com/contents.html

作者文笔风骚,干货满满,绝对五星好评.


* 概览: 结构,性能以及游戏.

"每当提到所谓 *优雅* 的方案,我们想要的往往是用尽量少的代码驱动尽量多的用例."

顾名思义,这篇文章将要介绍一些在游戏设计中常用的模式.
在展开之前先给大家几个tip:
- 如果不是确定非常需要,不轻易进行模块化和解耦,毕竟都是有代价的嘛..
- 可以糙快猛的响应策划需求,但需时常注意代码结构,积累太多垃圾代码就不好玩了.
- 随时考虑代码结构的性能,而尽量把底层优化推后.
- 重构不必过于追求完美 (处女座退散

* 一些通用设计模式
下面这几个模式大家都比较熟,也并不仅被应用于游戏开发中,在这里就不展开介绍了.
- 命令模式(Command)
- 享元模式(Flyweight) 
- 观察者模式(Observer)
- 原型(Prototype)
- 单例(Singleton)
- 状态(State)

* 用于时序的模式 (Sequencing Patterns)
(乍一看标题可能不太好理解, 撸主当初还以为是Sequence Queue之类的东西, 真是too young..)

简而言之, 所有需要one by one处理一坨事务的行为模式都可以称为sequencing patterns. 这里介绍三种.
** 双缓冲 Double buffer
*** 目的
使得一系列有序操作得以迅速且 *平滑* 的进行.

*** 模式简介
了解引擎的同学应该对这个概念比较熟悉. 双缓冲应用比较广的一个场景是在Rendering阶段:

渲染好的像素首先输出到frame buffer, 然后buffer中的内容会被输出到显示设备.
如果只有一个buffer, 会出现边更新边输出的状况, 显示设备上画面可能会出现撕裂. 双缓冲和三缓冲等技术是为了避免这个问题:
使用两个buffer来储存渲染画面. 分别为 back buffer 和 front buffer. 当front buffer被输出时, 下一帧的数据被放在back buffer中. front输出完毕后交换两个buffer.

*** 何时用
- 需要频繁的改变一些状态
- 需要在改变时访问状态
- 状态改变在进行时禁止被代码访问
- 而代码不希望等到改变结束才能访问

*** 安全食用指南
- 交换操作必须是原子的
- 它会增加内存占用
  
** 游戏循环 Game loop
*** 目的
将游戏速度与用户输入及处理器速度解耦,并且使我们能够操控游戏速度.

*** 模式简介
这货对很多人来说太熟悉了,就是常用的Update方法嘛. 

游戏循环在游戏运行过程中以一定速率(比如60fps)持续运行. 在每一次循环中, 程序需要响应用户输入, 更新游戏状态, 以及进行图形渲染
(为了同时保证游戏的流畅性和时效性, 这些的操作一般不会互相阻塞, 而且运行频率也不同). 通过游戏循环, 我们可以方便的控制游戏的进行速度.

奉上unity的game loop作为参考,内有漂亮的图: http://docs.unity3d.com/Manual/ExecutionOrder.html

*** 何时用
一般不需要自己造轮子, 它是如此重要, 以至于游戏引擎都把它视为不可分割的一部分.

*** 安全食用指南
- 性能至关重要. 如果说一个程序花费90%的时间在10%的代码上,那Game Loop无疑就是这10%部分,所以需要额外关注它的性能.
- 在有些平台上, GameLoop可能需要与平台内嵌的UI/Event Loop和谐相处,这听起来就很蛋疼. 好在最近流行的平台上不容易碰到这个问题,或者已经被引擎处理好了.

** 更新 Update
*** 目的
每帧逐一通知自己所管理的物件前进一帧, 以此驱动这些物件的行为.

*** 模式简介
维护一个对象集合.每个对象实现一个更新的方法,模拟一帧对象的行为,每帧游戏逐一调用每一个对象的更新方法.

*** 何时用
- 有GameLoop的地方就可以用, 尤其当需要同步的物件特别多时.
- 每个物件的行为模式相对独立.
- 物件的行为依赖于时间.

*** 安全食用指南
- 把逻辑分散到众多对象中后, 代码结构会变得更离散,更复杂.
- 处理游戏暂停变的更难了, 返回游戏时需要恢复update之前的运行状态, 比如继续之前未完的遍历.
- 写下茫茫多的update调用之后, 往往会发现这些语句之间有时序依赖, 需要格外当心.


* 用于实现行为的模式

** Bytecode
*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南

** Subclass Sandbox
*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南

** Type Object
*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南


* 用于解耦的模式
码代码容易, 应付日新月异的需求难, 解耦可以让生活轻松一点点.

** Component

*** 目的
允许一个实体应用在多种互相无耦合的域中.

*** 模式简介
熟悉Unity的同学有木有亲切..没错,Unity框架的核心GameObject就是根据这个思路设计的, 可以说此Component即彼Component.

这个模式即: 一个Component可以被应用在多个实体中。为了使实体保持无耦合, 逻辑代码分散到各自的Component中, 实体蜕化为一个存放Component的集合.

*** 何时用
*** 安全食用指南

** Event Queue
*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南

** Service Locator
*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南


* 用于优化性能的模式
** Data Locality
** Dirty Flag
** Object Pool
** Spatial Partition

*** 目的
*** 模式简介
*** 何时用
*** 安全食用指南


写到最后感到简直是把原书的目录给翻译了一遍, 忧桑... 

虽然如此, 还是希望这篇文章能够在15分钟内给低年级同学一个关于游戏模式的大概印象, 或者帮助中高年级同学整理一下知识结构, 如有同学发现错误求尽快指正

最后说句自己的感受...设计模式打嘴炮容易应用难,需要时刻以强大的意志力保证在应付繁杂的需求的同时保持敏感,克服惯性,克服懒,愿圣光护佑着你...

