#+TITLE:     SICP-CH2-构造数据抽象
#+AUTHOR:    Tsubasa
#+EMAIL:     tsubasa.wp@gmail.com
#+DATE:      2016-04-05
#+STARTUP:   latexpreview

* 数据抽象索引
=数据抽象= 是一种科学方法,它使我们能将一个复合数据对象的使用,与该数据对象怎样由更基本的数据对象构造起来的细节隔离开.

** 实例:有理数的算术运算
=表数据结构= 从序对构造起来的数据对象

关键字:cond, car, cdr

定义有理数过程:
: ;; 定义有理数并用gcd优化
: (define (make-rat n d)
:   (let ((g (gcd n d)))
:     (cons (/ n g)  (/ d g))))
: ;; 分子
: (define (number x) (car x))
: ;; 分母
: (define (denom x) (cdr x))
: ;; print
: (define (print-rat x)
:   (newline)
:   (display (number x))
:   (display "/")
:   (display (denom x)))
: ;; test val->1/2
: (print-rat (make-rat 2 -4))
: 
:

** 习题2.1
: (define (make-rat n d)
:   (let ((g (gcd (abs n) (abs d))))
:     (cond ((> (* n d) 0)
:            (cons (/ (abs n) g)  (/ (abs d) g)))
:           (else  (cons (- 0 (/ (abs n) g)) (/ (abs d) g))))))

** 抽象屏障
数据抽象的基本思想是:为每一类数据对象标识出一组操作,使得对这类数据对象的操作都可以基于它们表述,并且只使用它们.
** 习题2.2
: (define (make-point x y) (cons x y))
: (define (x-point x) (car x))
: (define (y-point x) (cdr x))
: (define (make-segment x y) (cons x y))
: (define (start-point x) (car x))
: (define (end-point x) (cdr x))
: (define (print-point p)
:   (newline)
:   (display "(")
:   (display (x-point p))
:   (display ",")
:   (display (y-point p))
:   (display ")"))
: 
: (define (mid-point segment)
:   (print-point (make-point
:    (/ (+ (x-point (start-point segment)) (x-point (end-point segment))) 2)
:    (/ (+ (y-point (start-point segment)) (y-point (end-point segment))) 2))))
: 
: (mid-point (make-segment (make-point 1.0 1.0) (make-point 4 5)))
: ;; value-> (2.5,3.)

** 习题2.3
: (define (double x) (* x x))
: (define (make-rect p1 p2 p3)
:   (cons (make-segment p1 p2) (make-segment p2 p3)))
: (define (h-side rect) (car rect))
: (define (v-side rect) (cdr rect))
: (define (lenth seg)
:   (let ((p1 (x-point seg))
:         (p2 (y-point seg)))
:   (sqrt
:    (+
:     (double (- (x-point p1) (x-point p2)))
:     (double (- (y-point p1) (y-point p2)))))))
: (define (rect-length rect)
:   (* (+
:       (lenth (h-side rect))
:       (lenth (v-side rect)))
:      2))
: (define (rect-area rect)
:   (*  (lenth (h-side rect))
:       (lenth (v-side rect))))
: 
: ;; test
: (lenth (make-segment (make-point 1 1) (make-point 2 2))) 
: ;Value: 1.4142135623730951
: 
: (rect-length
:  (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
: ;Value: 6.82842712474619
: 
: (rect-area
:  (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
: ;Value: 2.8284271247461903

** 数据意味着什么
=数据= 是一组适当的 *构造函数* 和 *选择函数* ,以及为了使这些过程成为一套合法的表示, 它们必须满足的一组*特定条件*

条件可能不太好理解, 举例来说, *序对* 这种数据的car和cdr操作需要满足的条件就是:
任何对象x和y, 如果z是(cons x y),那么(car z)就是x, (cdr z)就是y.

=数据的过程性表示= lisp/scheme甚至可以用过程来表示序对:
: (define (cons x y)
:  (define (dispatch m)
:    (cond ((= m 0) x)
:          ((= m 1) y)
:          (else (error "argument not 0 or 1")))
:   dispatch))
: 
: (define (car z) (z 0))
: (define (cdr z) (z 1))

(cons x y)返回一个过程. 当然scheme和一般的lisp并不会这样实现序对,主要是出于性能考虑.

在第三章可以看到,数据的过程性表示在设计中扮演着一种重要的角色,这种风格叫做 =消息传递=

** 习题2.4
代换过程:
: (car (cons x y))
: ((cons x y) (lambda (p q) p))
: ;把(lambda (p q))作为m带入(lambda (m) (m x y))
: ((lambda (p q) p) x y)
: ;应用x,y,得到
: value->x

** 习题2.5
2和3都是质数,可以利用质数相乘的性质储存a和b.
: (define (cons-expt x y)
:   (* (expt 2 x) (expt 3 y)))
:
: (define (car-expt x)
:   (define (iter a n)
:     (cond ((= 0 (remainder a 2)) (iter (/ a 2) (+ n 1)))
:           (else n)))
:   (iter x 0))
: 
: (define (cdr-expt x)
:   (define (iter a n)
:     (cond ((= 0 (remainder a 3)) (iter (/ a 3) (+ n 1)))
:           (else n)))
:   (iter x 0))
: 
: (car-expt (cons-expt 5 6)) ;value->5
: (cdr-expt (cons-expt 5 6)) ;value->6

** 习题2.6
使用church计数的表示形式定义one和two. (讲真我对着这道题发呆好久....

: (define zero (lambda (f) (lambda (x) x)))
: (define (add-1 n)
:   (lambda (f) (lambda (x) (f (n f) x))))
: 
: ; 首先展开add-1
: (add-1 zero)
: (lambda (f) (lambda (x) (f ((zero f) x))))
: (lambda (f) (lambda (x) (f ((lambda(x) x) x))))
: (lambda (f) (lambda (x) (f x)))
: (add-1 one)
: (lambda (f) (lambda (x) (f ((one f) x))))
: (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
: (lambda (f) (lambda (x) (f (f x))))
: ; 定义one
: (define one (lambda (f) (lambda (x) (f x))))
: ; 定义two
: (define two (lambda (f) (lambda (x) (f (f x)))))
: ;根据观察得出规律规律:one的定义中应用了一次f, two的定义中应用了2次f, 所以这类过程可以理解为用'应用f的次数'来表示数字.
定义通用的加法:
: (define (add a b)
:   (lambda(f) (lambda(x) ((a f) ((b f) x)))))
这个定义的思路是把a和b中应用f的过程叠加. 下面测试一下:
: (add one two)
: (lambda(f) (lambda(x) ((lambda(x) (f x)) ((lambda(x) (f (f x))) x))))
: (lambda(f) (lambda(x) ((lambda(x) (f x)) (f (f x)))))
: (lambda(f) (lambda(x) (f (f (f x)))))

** 扩展练习:区间算术

** 习题2.7
: (define (make-interval a b) (cons a b))
: (define (upper-bound x) (car x))
: (define (lower-bound x) (cdr x))

** 习题2.8
: (define (sub-interval a b)
:   (make-interval (- (upper-bound a) (upper-bound b))
:                  (- (lower-bound a) (lower-bound b))))

** 习题2.9
对加/减运算而言:
$w(a+b)=(u(a+b)-l(a+b))/2=(((u(a)+u(b))-(l(a)+l(b)))/2=(w(a)+w(b))$
所以两个区间的和/差的宽度函数就是被加/减的区间的宽度函数.

对乘法而言:

有区间A=[0,2],宽度为1;B=[0,4],宽度为2;
A*B=[0,8],宽度为4. 所以$w(A*B)\neq w(A)*w(B)$.

对除法而言:
A/B=[0,1/2],宽度为1/4. 而w(A)/w(B)=1/2; 所以$w(A/B)\neq w(A)/w(B)$.

** 习题2.10
: ; 首先定义一个检查过程
: (define (valid-interval x)
:   (if (< (* (upper-bound x) (lower-bound x)) 0) false true))
: ; 重新定义除法
: (define (div-interval x y)
:   (if (and (valid-interval x) (vali-interval y))
:       (mul-interval x
:                     (make-interval (/ 1.0 (upper-bound y))
:                                    (/ 1.0 (lower-bound y))))
:       (display "error:invalid param")))

** 习题2.11
根据区间是否跨过0|是否全为正|是否全为负分为9种情况.
- a > 0, b > 0
- a > 0, b < 0
- a > 0, b cross 0
- a cross 0, b > 0
- a cross 0, b < 0
- a cross 0, b cross 0
- a < 0, b > 0
- a < 0, b < 0
- a < 0, b cross 0

定义快速乘法(有个问题..当a和b都跨越0时,需要4次乘法运算)
: (define (is-cross-zero x)
:   (if (< (* (upper-bound x) (lower-bound x)) 0) true false))
: (define (is-positive x)
:   (if (>= (lower-bound x) 0) true false))
: (define (is-negative x)
:   (if (< (upper-bound x) 0) true false))
: 
: (define (fast-mul-interval x y)
:   (cond
:    ((and (is-positive x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (lower-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-positive x) (is-negative y))
:     (make-interval
:      (* (upper-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-positive x) (is-cross-zero y))
:     (make-interval
:      (* (upper-bound x) (lower-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-negative x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (upper-bound x) (lower-bound y))))
:    ((and (is-negative x) (is-negative y))
:     (make-interval
:      (* (upper-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-negative x) (is-cross-zero y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-cross-zero x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-cross-zero x) (is-negative y))
:    (make-interval
:     (* (upper-bound x) (lower-bound y))
:     (* (lower-bound x) (lower-bound y))))
:   ((and (is-cross-zero x) (is-cross-zero y))
:    (make-interval
:     (min (* (lower-bound x) (upper-bound y)) (* (upper-bound x) (lower-bound y)))
:     (max (* (upper-bound x) (upper-bound y)) (* (lower-bound x) (lower-bound y)) )))))

与Alyssa的暴力乘法进行比较测试(吐血...
: (fast-mul-interval (make-interval 1 2) (make-interval 1 2))
: (mul-interval (make-interval 1 2) (make-interval 1 2))
: ;; Value : (1 . 4)
: 
: (fast-mul-interval (make-interval 1 2) (make-interval -1 -2))
: (mul-interval (make-interval 1 2) (make-interval -1 -2))
: ;; Value : (-4 .-1)
: 
: (fast-mul-interval (make-interval 1 2) (make-interval -1 2))
: (mul-interval (make-interval 1 2) (make-interval -1 2))
: ;; Value : (-2, 4)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval 1 2))
: (mul-interval (make-interval -2 -1) (make-interval 1 2))
: ;; Value : (-4, -1)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval -2 -1))
: (mul-interval (make-interval -2 -1) (make-interval -2 -1))
: ;; Value : (1, 4)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval -1 2))
: (mul-interval (make-interval -2 -1) (make-interval -1 2))
: ;; Value : (-4, 2)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval 1 2))
: (mul-interval (make-interval -2 1) (make-interval 1 2))
: ;; Value : (-4, 2)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval -2 -1))
: (mul-interval (make-interval -2 1) (make-interval -2 -1))
: ;; Value : (-2, 4)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval -5 2))
: (mul-interval (make-interval -2 1) (make-interval -5 2))
: ;; Value : (-5, 10)

** 习题2.12
: (define (make-center-percent center percent)
:   (make-interval (- center (* center percent))
:                  (+ center (* center percent))))
: (define (percent range)
:   (let ((width (/ (- (upper-bound range) (lower-bound range)) 2))
:         (mid (/ (+ (upper-bound range) (lower-bound range)) 2)))
:         (/ width mid)))

** 习题2.13
计算精度的公式是简单相加:
: (define (percent-mul r1 r2)
:   (+ (percent r1) (percent r2)))
测试一下
: (percent (mul-interval (make-interval 9.99 10.01) (make-interval 9.99 10.01)))
: (percent-mul (make-interval 9.99 10.01) (make-interval 9.99 10.01))


然后分析part1,part2的问题:
: (define (part1 r1 r2)
:   (div-interval (mul-interval r1 r2)
:                 (add-interval r1 r2)))
: (define (part2 r1 r2)
:   (let ((one (make-interval 1 1)))
:     (div-interval one
:                   (add-interval (div-interval one r1)
:                                 (div-interval one r2)))))
: 
: (part1 (make-interval 1 2) (make-interval 1 2)) ;val-> (.25,2)
: (part2 (make-interval 1 2) (make-interval 1 2)) ;val-> (.5 1)
猜测是运算顺序不同导致精度变化不同

** 习题2.14
首先验证上面的猜测
: (let ((r1 (make-interval 1.0 2))
:        (r2 (make-interval 1.0 2))
:       (one (make-interval 1.0 1.0)))
:   (percent r1)  ; .33
:   (percent (mul-interval r1 r2)) ; .6 放大2倍
:   (percent (div-interval r1 r2)) ; .6 放大2倍
:   (percent (add-interval r1 r2)) ; .33 不变
:   (percent (div-interval one r1)) ; .33 不变
:   (percent (part1 r1 r2)) ; .77 放大2.28倍
:   (percent (part2 r1 r2)) ; .33 
:   )

可见,直接对两个区间进行乘法或除法操作会将精度放大.而加法以及被one除不会放大精度.

在part1的运算过程中,乘法将精度放大2倍, 用放大的乘积除以和之后从0.6放大到0.77. 
而在part2中,由于全是除以1的操作.精度没有发生变化.

** 习题2.15
eva说的对. part2中的运算都没有造成精度区间扩大,所以是更好的程序.

** 习题2.16
(作者说此题非常难...怕

我先想到了除法运算可能长这样:
: (define (better-div-interval r1 r2)
:   (let ((one (make-interval 1 1)))
:     (better-mul-interval r1  (div-interval one r2))))
但首先要能定义出一个better-mul-interval

我实在编不下去了! google了一下,这道题真的很难,涉及到比较艰深的数学问题. 贴个链接在这里吧:
http://stackoverflow.com/questions/14130878/sicp-2-16-interval-arithmetic-scheme

* 层次性数据和闭包性质
=操作的闭包性质= 通过某种操作组合起来的数据对象得到的结果本身还可以通过同样的操作再进行组合.

** 序列的表示
序列可以通过嵌套cons操作构造起来
: (cons 1
:     (cons 2
:         (cons 3
:             (cons 4 ))))

scheme为了方便表的构造而提供了一个基本操作list.所以上面序列也可以通过以下方式产生:
: (list 1 2 3 4)
它们是等价的.

*** 对表的操作
=car= 可以被看做获取表第一项元素的操作
=cdr= 可以看做获取表剩下的元素的操作
=nil= 用于表示序对链的结束

可以这样实现索引:
: (define (list-ref item n)
:   (if (= n 0)
:       (car item)
:       (list-ref (cdr item) (- n 1))))

=null?= 用于检查是否是空表.
利用null实现length:
: (define (length items)
:   (if (null? items)
:       0
:       (+ 1 (length (cdr items)))))

*** 习题2.17
获取序列的最后一个元素
: (define (last-pair items)
:   (if (= 1 (length items))
:       (list (car items))
:       (last-pair (cdr items))))

*** 习题2.18
返回逆序序列
: (define (reverse items)
:   (if (= 1 (length items))
:       items
:       (append (reverse (cdr items)) (list (car items)))))

*** 习题2.19
利用序列优化1.22的找硬币程序,把币种存储在序列中
: (define us-coins (list 50 25 10 5 1))
: (define uk-coins (list 100 50 20 10 5 2 1 0.5))
: (define (except-first-denomination coin-values) (cdr coin-values))
: (define (first-denomination coin-values) (car coin-values))
: (define (no-more? coin-values) (if (null? coin-values) true false))
: (define (cc amount coin-values)
:   (cond ((= amount 0 ) 1)
:         ((or (< amount 0) (no-more? coin-values)) 0)
:         (else
:          (+ (cc amount
:                 (except-first-denomination coin-values))
:             (cc (- amount
:                    (first-denomination coin-values))
:                 coin-values)))))
币种的排序不会影响结果.因为针对每种硬币,都会从总金额amount开始重新计算, 测试结果是互相独立的.

*** 习题2.20
这道题说明了scheme怎样定义带有任意多参数的过程

具体方式是使用点尾:
: (define (f x y . z) <body>)
那么如果求值(f 1 2 3 4 5),则x=1,y=2,然后z=(3,4,5),是一个list. (原来是这样...

请用这种记法写出same-parity:返回与其第一个参数有同样奇偶性质的表
: ;首先定义一个选择器,它接受一个过程参数f,然后用f来过滤出子序列
: (define (filter items f)
:   (cond
:    ((null? items) (list))
:    ((f (car items))
:     (append (list (car items)) (filter (cdr items) f)))
:    (else
:     (append (list) (filter (cdr items) f)))))
然后定义same-party.为了简化我首先利用append把x,y,z整合成一个序列
: (define (same-party x y . z)
:   (let ((param-list
:          (append (list x) (append (list y) z))))
:     (if
:      (odd? x)
:      (filter param-list odd?)
:      (filter param-list even?))))
测试
: (same-party 2 1 2 3 4 5 6 7 8) ; value: (1 3 5 7)
: (same-party 1 2 3 4 5 6 7 8)   ; value: (2 2 4 6 8)

*** 对表的映射
=map= 是一种公共模式,而且建立起了一种处理表的高层抽象
: (define (map proc items)
:   (if (null? items)
:       (list)
:       (cons (proc (car items))
:             (map proc (cdr items)))))

*** 习题2.21
: (define (square-list items)
:   (if (null? items)
:       '()
:       (cons (square (car items)) (square-list (cdr items)))))
: 
: (define (square-list items)
:   (map square items))

*** 习题2.22
第一个迭代错在cons的顺序,把answer放在最后会变成倒序
: (cons (...) answer)
而修改后的程序把answer放在前面,虽然看起来顺序对了,但cons的第一个参数是嵌套的cons,最后生成的序列会长这样:
: ((((. .) .) .) .)

*** 习题2.23
实现一个for-each
#+BEGIN_SRC scheme
(define (for-each proc items)
  (if (null? items)
       ()
       (begin
         (proc (car items))
         (for-each proc (cdr items)))))
#+END_SRC

** 层次结构
将表作为序列的方式,可以自然的推广到表示那些元素本身也是序列的序列,也就是
=树=. 

=pair?= scheme提供的基本过程, 检查参数是否为序对.

*** 习题2.24
#+BEGIN_SRC scheme
(list 1 (list 2 (list 3 4) 5))
;Value 89: (1 (2 (3 4) 5))
#+END_SRC

#+BEGIN_SRC c
     N
  /     \
1        N    
       / | \  
      2  N  5
        / \
       3   4
#+END_SRC

*** 习题2.25
#+BEGIN_SRC scheme
(cdr (car (cdr (cdr mt1))))
(cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr mt2)))))))))))
#+END_SRC

*** 习题2.26
#+BEGIN_SRC scheme
(append x y) ;Value 101: (1 2 3 4 5 6)
(cons x y)   ;Value 102: ((1 2 3) 4 5 6)
(list x y)   ;Value 103: ((1 2 3) (4 5 6))
#+END_SRC

*** 习题2.27
实现深度逆序.这道题目真是折腾死宝宝了,一开始有个关键点没搞明白,导致瞎写了一通.
这个关键的地方是:如果(cdr list)是一个list:
: (list 1 (list 2 3))
那么它的逆序则是
: (append (cdr list) (car list))
但如果(car list)是list,就稍微有点绕:
: (list (list 1 2) 3)
那么它的逆序则是
: (append (cdr list) (list (car list)))
原因是append或者cons会把第二个参数展开(去掉一层list), 所以不能直接使用(car x)当做第二个参数.           

深度逆序:
#+BEGIN_SRC scheme
(define (deep-revers tree)
  (cond
   ((null? tree) ())
   ((not (pair? tree)) (list tree))
   ((pair? (car tree))
      (append (deep-revers (cdr tree)) (list (deep-revers (car tree)))))
   (else
      (append (deep-revers (cdr tree)) (deep-revers (car tree))))))
#+END_SRC

*** 习题2.28
#+BEGIN_SRC scheme
(define (fringe tree)
  (cond
   ((null? tree) ())
   ((not (pair? tree)) (list tree))
   (else
    (append (fringe (car tree))
            (fringe (cdr tree)))
        )))
#+END_SRC

*** 习题2.29
-a) 获取左右子树,右子树稍稍注意:
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))
#+END_SRC

- b) 递归计算子树长度(左边叶子之和)
#+BEGIN_SRC scheme
(define (branch-length branch)
  (cond
   ((null? branch) 0)
   ((not (pair? branch)) 0)
   (else
    (+ (car branch) (branch-length (right-branch branch))))))
#+END_SRC

递归计算重量(右叶子之和)
#+BEGIN_SRC scheme
(define (branch-weight branch)
  (cond
   ((null? branch) 0)
   ((not (pair? branch)) branch)
   (else
    (branch-weight (right-branch branch)))))

(define (total-weight mobile)
  (+
   (branch-length (left-branch mobile))
   (branch-length (right-branch mobile))))
#+END_SRC

- c) 计算是否平衡,简单的乘法.
#+BEGIN_SRC scheme
(define (is-balance mobile)
  (=
   (* (branch-weight (left-branch mobile)) (branch-length (left-branch mobile)))
   (* (branch-weight (left-branch mobile)) (branch-length (right-branch mobile)))))
#+END_SRC

- d) 只需修改right-branch方法
#+BEGIN_SRC scheme
(define (right-branch mobile)
  (cdr mobile))
#+END_SRC

*** 对树的映射
把map与递归结合是处理树的一种强有力的抽象

*** 习题2.30
定义square-tree
#+BEGIN_SRC scheme
(define (map-tree tree f)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (map-tree sub-tree f)
             (f sub-tree)))
       tree))
(map-tree (list 1 2 (list 3 4)) square)
; value: (1 4 (9 16))
#+END_SRC

*** 习题2.31
将2.30进一步抽象. (还好宝宝机智,已经抽象好了
: (define (square-tree tree) (map-tree tree square))

*** 习题2.32
计算全排列(又学到一种算排列的新姿势
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      ()
      (let ((reset (subsets (cdr s))))
        (append reset
                (cons
                 (car s) 
                 (map (lambda (sub) (append (car s) sub)) reset))))))
#+END_SRC
倒数第3行用cons比较安全. 如果(map..)计算结果是nil, 则cons会把nil省略而list或append会把()放进结果中.
作这道题一开始append结果总跟预想的不一样,经测试(append 1 2)的结果是个序对(1 . 2)而不是list(1 2).
后来修改了之前的append实现才搞定:
#+BEGIN_SRC scheme
(define (append list1 list2)
  (cond ((null? list1)
         list2)
        ((null? list2) ;; 对list2=nil的情况进行处理
         list1)
        ((and (not (pair? list1)) (not (pair? list2)))
         (list list1 list2)) ;; 两个都是简单数据时返回list,而不是序对
        ((not (pair? list1))
         (cons list1 list2)) ;; list1是简单数据时直接cons,否则后面会对它car/cdr
        (else
         (cons (car list1) (append (cdr list1) list2)))))
#+END_SRC

** 序列作为一种约定的界面
这里介绍与数据结构有关的另一种强有力的设计原理 *使用约定的界面*.

举个例子,定义一个过程,枚举所有叶子,并计算出那些值为奇数的叶子的平方和.
这个过程可以抽象成一个信号流:
| enumerate:  | filter: | map:   | accumulate: |
| tree leaves | odd?    | square | +, 0        |
如果我们能良好的组织成熟,使得 =信号流结构= 明显的表现在写出的过程中,将会大大提高代码的清晰性.

*** 序列操作
要清晰的反应信号流结构, 最关键的一点就是将注意力集中在处理过程从一个步骤流向下一个步骤的"信号".

- *map* 可以利用2.2.1节的map来表现信号流图中的映射步骤.
: (map square (list 1 2 3 4 5)

- *filter* 
#+BEGIN_SRC scheme
(define (filter predicate sequence)
  (cond ((null? sequence) ())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
#+END_SRC

- *accumulate* 定义计算步骤
#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
#+END_SRC

- *enumerate* 定义树的枚举
#+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) ())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
#+END_SRC

利用这些步骤来定义前面的例子:
#+BEGIN_SRC scheme
(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
#+END_SRC

这样我们就得到了一个由许多独立程序片段组合构成的设计.

*** 习题2.33
#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) () sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))
#+END_SRC

*** 习题2.34
#+BEGIN_SRC scheme
(define (horner-eval x sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              sequence))

(horner-eval 2 (list 1 3 0 5 0 1));Value: 79
#+END_SRC

*** 习题2.35
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate (lambda (x y) (+ x y))
              0
              (map (lambda (x) (length (enumerate-tree x))) t)))
(count-leaves (list 1 2 (list 2 3 4))) ; Value:5
#+END_SRC

*** 习题2.36
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      ()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 1 2 3)))
#+END_SRC

*** 习题2.37
实现矩阵点的各种基本运算
#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (accumulate-n * 1 (list v w))))

(define (matrix-*-vector m v)
  (map
   (lambda (x) (dot-product x v))
   m))
(define (transpose m)
  (accumulate-n (lambda (x y) (cons x y)) () m))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (col) (matrix-*-vector m col)) cols)))
#+END_SRC
测试:
#+BEGIN_SRC scheme
(define mv (list 1 2 3))
(define mm (list (list 1 2 3) (list 4 5 6) (list 4 5 6)))
(dot-product mv mv);Value: 14
(matrix-*-vector mm mv);Value 269: (14 32 32)
(transpose mm);Value 266: ((1 4) (2 5) (3 6))
(matrix-*-matrix mm mm);Value 268: ((21 48 48) (27 63 63) (33 78 78))
#+END_SRC

*** 习题2.38
#+BEGIN_SRC scheme
(fold-right / 1 (list 1 2 3)) ;;Value: 3/2
(fold-left / 1 (list 1 2 3))  ;;Value: 1/6
(fold-right list () (list 1 2 3));Value 270: (1 (2 (3 ())))
(fold-left list () (list 1 2 3));Value 271: (((() 1) 2) 3)
#+END_SRC
保证fold-right和fold-left都相同的条件是,运算满足交换律.

*** 习题2.39
#+BEGIN_SRC scheme
(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) () sequence))
  (define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) ()  sequence))
#+END_SRC

*** 嵌套映射
我们可以扩充序列泛型,将许多通常用嵌套循环表述的计算包含进来,  比如用append累积map的计算结果:
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append (list) (map proc seq)))
#+END_SRC

- ep1: 找出n以下所有和为素数的序对:
#+BEGIN_SRC scheme
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)
                ))))
#+END_SRC

-  ep2: 全排列
#+BEGIN_SRC scheme
(define (permutations s)
  (if (null? s)
      (list (list))
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
#+END_SRC

*** 习题2.40
#+BEGIN_SRC scheme
(define (unique-pairs low high)
  (flatmap (lambda (x) 
         (map (lambda (y) (list x y))
              (enumerate-interval (+ x 1) high)))
           (enumerate-interval low high)))
(unique-pairs 1 3);;=> ((1 2) (1 3) (2 3))
(define (prime-sum-pair n)
  (filter prime-sum? (unique-pairs 1 n)))
(prime-sum-pair 3)
#+END_SRC

*** 习题2.41
#+BEGIN_SRC scheme
(define (unique-triples low high)
  (flatmap (lambda (x)
             (map (lambda (i) (append x i)) (unique-pairs (+ x 1) high)))
           (enumerate-interval low high)))
(unique-triples 1 4)
(define (prime-sum-triple? list)
  (prime? (+ (car list) (cadr list) (cadr (cdr list)))))
(define (prime-sum-triples n)
  (filter prime-sum-triple? (unique-triples 1 n)))
(prime-sum-triples 4) ;;=> ((1 2 4) (2 3 4))
#+END_SRC

*** 习题2.42
经典的8皇后问题,回溯法.
#+BEGIN_SRC scheme
(define (queens board-size)
  (define (queen-cols k)
    (if (= 0 k)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
        (queen-cols board-size))
#+END_SRC

#+BEGIN_SRC scheme
(define empty-board (list))
#+END_SRC
空棋盘就是nil
#+BEGIN_SRC scheme
(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))
#+END_SRC
k其实没有用到,大概留出这个参数是为了便于替换成其它算法.

#+BEGIN_SRC scheme
(define (safe? k positions)
  (define (safe-iter x rest distance)
    (cond ((null? rest) #t)
          ((= x (car rest)) #f)
          ((= distance (abs (- x (car rest)))) #f)
          (else (safe-iter x (cdr rest) (+ distance 1)))))
  (safe-iter (car positions) (cdr positions) 1))
(queens 4);;Value 458: ((3 1 4 2) (2 4 1 3))
#+END_SRC
遍历rest, 检查相同行中是否存在皇后, 以及对角线是否存在皇后.

*** 习题2.43
2.42解法只需要递归的计算一遍queen-cols,而Reasoner需要递归T遍,导致最后解题事件变成了
 $T*board-size$

** 实例:一个图形语言

