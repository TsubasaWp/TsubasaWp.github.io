#+TITLE:     SICP-CH2-构造数据抽象
#+AUTHOR:    Tsubasa
#+EMAIL:     tsubasa.wp@gmail.com
#+DATE:      2016-04-05
#+STARTUP:   latexpreview

* 数据抽象索引
=数据抽象= 是一种科学方法,它使我们能将一个复合数据对象的使用,与该数据对象怎样由更基本的数据对象构造起来的细节隔离开.

** 实例:有理数的算术运算
=表数据结构= 从序对构造起来的数据对象

关键字:cond, car, cdr

定义有理数过程:
: ;; 定义有理数并用gcd优化
: (define (make-rat n d)
:   (let ((g (gcd n d)))
:     (cons (/ n g)  (/ d g))))
: ;; 分子
: (define (number x) (car x))
: ;; 分母
: (define (denom x) (cdr x))
: ;; print
: (define (print-rat x)
:   (newline)
:   (display (number x))
:   (display "/")
:   (display (denom x)))
: ;; test val->1/2
: (print-rat (make-rat 2 -4))
: 
:

** 习题2.1
: (define (make-rat n d)
:   (let ((g (gcd (abs n) (abs d))))
:     (cond ((> (* n d) 0)
:            (cons (/ (abs n) g)  (/ (abs d) g)))
:           (else  (cons (- 0 (/ (abs n) g)) (/ (abs d) g))))))

** 抽象屏障
数据抽象的基本思想是:为每一类数据对象标识出一组操作,使得对这类数据对象的操作都可以基于它们表述,并且只使用它们.
** 习题2.2
: (define (make-point x y) (cons x y))
: (define (x-point x) (car x))
: (define (y-point x) (cdr x))
: (define (make-segment x y) (cons x y))
: (define (start-point x) (car x))
: (define (end-point x) (cdr x))
: (define (print-point p)
:   (newline)
:   (display "(")
:   (display (x-point p))
:   (display ",")
:   (display (y-point p))
:   (display ")"))
: 
: (define (mid-point segment)
:   (print-point (make-point
:    (/ (+ (x-point (start-point segment)) (x-point (end-point segment))) 2)
:    (/ (+ (y-point (start-point segment)) (y-point (end-point segment))) 2))))
: 
: (mid-point (make-segment (make-point 1.0 1.0) (make-point 4 5)))
: ;; value-> (2.5,3.)

** 习题2.3
: (define (double x) (* x x))
: (define (make-rect p1 p2 p3)
:   (cons (make-segment p1 p2) (make-segment p2 p3)))
: (define (h-side rect) (car rect))
: (define (v-side rect) (cdr rect))
: (define (lenth seg)
:   (let ((p1 (x-point seg))
:         (p2 (y-point seg)))
:   (sqrt
:    (+
:     (double (- (x-point p1) (x-point p2)))
:     (double (- (y-point p1) (y-point p2)))))))
: (define (rect-length rect)
:   (* (+
:       (lenth (h-side rect))
:       (lenth (v-side rect)))
:      2))
: (define (rect-area rect)
:   (*  (lenth (h-side rect))
:       (lenth (v-side rect))))
: 
: ;; test
: (lenth (make-segment (make-point 1 1) (make-point 2 2))) 
: ;Value: 1.4142135623730951
: 
: (rect-length
:  (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
: ;Value: 6.82842712474619
: 
: (rect-area
:  (make-rect (make-point 1 1) (make-point 2 2) (make-point 0 2))) 
: ;Value: 2.8284271247461903

** 数据意味着什么
=数据= 是一组适当的 *构造函数* 和 *选择函数* ,以及为了使这些过程成为一套合法的表示, 它们必须满足的一组*特定条件*

条件可能不太好理解, 举例来说, *序对* 这种数据的car和cdr操作需要满足的条件就是:
任何对象x和y, 如果z是(cons x y),那么(car z)就是x, (cdr z)就是y.

=数据的过程性表示= lisp/scheme甚至可以用过程来表示序对:
: (define (cons x y)
:  (define (dispatch m)
:    (cond ((= m 0) x)
:          ((= m 1) y)
:          (else (error "argument not 0 or 1")))
:   dispatch))
: 
: (define (car z) (z 0))
: (define (cdr z) (z 1))

(cons x y)返回一个过程. 当然scheme和一般的lisp并不会这样实现序对,主要是出于性能考虑.

在第三章可以看到,数据的过程性表示在设计中扮演着一种重要的角色,这种风格叫做 =消息传递=

** 习题2.4
代换过程:
: (car (cons x y))
: ((cons x y) (lambda (p q) p))
: ;把(lambda (p q))作为m带入(lambda (m) (m x y))
: ((lambda (p q) p) x y)
: ;应用x,y,得到
: value->x

** 习题2.5
2和3都是质数,可以利用质数相乘的性质储存a和b.
: (define (cons-expt x y)
:   (* (expt 2 x) (expt 3 y)))
:
: (define (car-expt x)
:   (define (iter a n)
:     (cond ((= 0 (remainder a 2)) (iter (/ a 2) (+ n 1)))
:           (else n)))
:   (iter x 0))
: 
: (define (cdr-expt x)
:   (define (iter a n)
:     (cond ((= 0 (remainder a 3)) (iter (/ a 3) (+ n 1)))
:           (else n)))
:   (iter x 0))
: 
: (car-expt (cons-expt 5 6)) ;value->5
: (cdr-expt (cons-expt 5 6)) ;value->6

** 习题2.6
使用church计数的表示形式定义one和two. (讲真我对着这道题发呆好久....

: (define zero (lambda (f) (lambda (x) x)))
: (define (add-1 n)
:   (lambda (f) (lambda (x) (f (n f) x))))
: 
: ; 首先展开add-1
: (add-1 zero)
: (lambda (f) (lambda (x) (f ((zero f) x))))
: (lambda (f) (lambda (x) (f ((lambda(x) x) x))))
: (lambda (f) (lambda (x) (f x)))
: (add-1 one)
: (lambda (f) (lambda (x) (f ((one f) x))))
: (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
: (lambda (f) (lambda (x) (f (f x))))
: ; 定义one
: (define one (lambda (f) (lambda (x) (f x))))
: ; 定义two
: (define two (lambda (f) (lambda (x) (f (f x)))))
: ;根据观察得出规律规律:one的定义中应用了一次f, two的定义中应用了2次f, 所以这类过程可以理解为用'应用f的次数'来表示数字.
定义通用的加法:
: (define (add a b)
:   (lambda(f) (lambda(x) ((a f) ((b f) x)))))
这个定义的思路是把a和b中应用f的过程叠加. 下面测试一下:
: (add one two)
: (lambda(f) (lambda(x) ((lambda(x) (f x)) ((lambda(x) (f (f x))) x))))
: (lambda(f) (lambda(x) ((lambda(x) (f x)) (f (f x)))))
: (lambda(f) (lambda(x) (f (f (f x)))))

** 扩展练习:区间算术

** 习题2.7
: (define (make-interval a b) (cons a b))
: (define (upper-bound x) (car x))
: (define (lower-bound x) (cdr x))

** 习题2.8
: (define (sub-interval a b)
:   (make-interval (- (upper-bound a) (upper-bound b))
:                  (- (lower-bound a) (lower-bound b))))

** 习题2.9
对加/减运算而言:
$w(a+b)=(u(a+b)-l(a+b))/2=(((u(a)+u(b))-(l(a)+l(b)))/2=(w(a)+w(b))$
所以两个区间的和/差的宽度函数就是被加/减的区间的宽度函数.

对乘法而言:

有区间A=[0,2],宽度为1;B=[0,4],宽度为2;
A*B=[0,8],宽度为4. 所以$w(A*B)\neqw(A)*w(B)$.

对除法而言:
A/B=[0,1/2],宽度为1/4. 而w(A)/w(B)=1/2; 所以$w(A/B)\neqw(A)/w(B)$.

** 习题2.10
: ; 首先定义一个检查过程
: (define (valid-interval x)
:   (if (< (* (upper-bound x) (lower-bound x)) 0) false true))
: ; 重新定义除法
: (define (div-interval x y)
:   (if (and (valid-interval x) (vali-interval y))
:       (mul-interval x
:                     (make-interval (/ 1.0 (upper-bound y))
:                                    (/ 1.0 (lower-bound y))))
:       (display "error:invalid param")))

** 习题2.11
根据区间是否跨过0|是否全为正|是否全为负分为9种情况.
- a > 0, b > 0
- a > 0, b < 0
- a > 0, b cross 0
- a cross 0, b > 0
- a cross 0, b < 0
- a cross 0, b cross 0
- a < 0, b > 0
- a < 0, b < 0
- a < 0, b cross 0

定义快速乘法(有个问题..当a和b都跨越0时,需要4次乘法运算)
: (define (is-cross-zero x)
:   (if (< (* (upper-bound x) (lower-bound x)) 0) true false))
: (define (is-positive x)
:   (if (>= (lower-bound x) 0) true false))
: (define (is-negative x)
:   (if (< (upper-bound x) 0) true false))
: 
: (define (fast-mul-interval x y)
:   (cond
:    ((and (is-positive x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (lower-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-positive x) (is-negative y))
:     (make-interval
:      (* (upper-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-positive x) (is-cross-zero y))
:     (make-interval
:      (* (upper-bound x) (lower-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-negative x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (upper-bound x) (lower-bound y))))
:    ((and (is-negative x) (is-negative y))
:     (make-interval
:      (* (upper-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-negative x) (is-cross-zero y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (lower-bound x) (lower-bound y))))
:    ((and (is-cross-zero x) (is-positive y))
:     (make-interval
:      (* (lower-bound x) (upper-bound y))
:      (* (upper-bound x) (upper-bound y))))
:    ((and (is-cross-zero x) (is-negative y))
:    (make-interval
:     (* (upper-bound x) (lower-bound y))
:     (* (lower-bound x) (lower-bound y))))
:   ((and (is-cross-zero x) (is-cross-zero y))
:    (make-interval
:     (min (* (lower-bound x) (upper-bound y)) (* (upper-bound x) (lower-bound y)))
:     (max (* (upper-bound x) (upper-bound y)) (* (lower-bound x) (lower-bound y)) )))))

与Alyssa的暴力乘法进行比较测试(吐血...
: (fast-mul-interval (make-interval 1 2) (make-interval 1 2))
: (mul-interval (make-interval 1 2) (make-interval 1 2))
: ;; Value : (1 . 4)
: 
: (fast-mul-interval (make-interval 1 2) (make-interval -1 -2))
: (mul-interval (make-interval 1 2) (make-interval -1 -2))
: ;; Value : (-4 .-1)
: 
: (fast-mul-interval (make-interval 1 2) (make-interval -1 2))
: (mul-interval (make-interval 1 2) (make-interval -1 2))
: ;; Value : (-2, 4)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval 1 2))
: (mul-interval (make-interval -2 -1) (make-interval 1 2))
: ;; Value : (-4, -1)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval -2 -1))
: (mul-interval (make-interval -2 -1) (make-interval -2 -1))
: ;; Value : (1, 4)
: 
: (fast-mul-interval (make-interval -2 -1) (make-interval -1 2))
: (mul-interval (make-interval -2 -1) (make-interval -1 2))
: ;; Value : (-4, 2)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval 1 2))
: (mul-interval (make-interval -2 1) (make-interval 1 2))
: ;; Value : (-4, 2)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval -2 -1))
: (mul-interval (make-interval -2 1) (make-interval -2 -1))
: ;; Value : (-2, 4)
: 
: (fast-mul-interval (make-interval -2 1) (make-interval -5 2))
: (mul-interval (make-interval -2 1) (make-interval -5 2))
: ;; Value : (-5, 10)

** 习题2.12
