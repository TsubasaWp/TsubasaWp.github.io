<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Game Programming Patterns Reading Note - org-page</title>
    <meta charset="utf-8" />
    <meta name="author" content="Tsubasa" />
    <meta name="description" content="reading note" />
    <meta name="keywords" content="reading note" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">org-page</a></h1>
        <p>static site generator</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/resource/">Resource</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/kelvinh/org-page">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="tsubasawp.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Game Programming Patterns Reading Note</h1>
<p>
其实这是篇读书笔记(捂脸...
</p>

<p>
对这个话题感兴趣又愿意花时间了解的同学直接移步这里吧
<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a>
</p>

<p>
作者文笔风骚,干货满满,绝对五星好评.
</p>


<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">概览: 结构,性能以及游戏.</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
"每当提到所谓 <b>优雅</b> 的方案,我们想要的往往是用尽量少的代码驱动尽量多的用例."
</p>

<p>
顾名思义,这篇文章将要介绍一些在游戏设计中常用的模式.
在展开之前先给大家几个tip:
</p>
<ul class="org-ul">
<li>如果不是确定非常需要,不轻易进行模块化和解耦,毕竟都是有代价的嘛..</li>
<li>可以糙快猛的响应策划需求,但需时常注意代码结构,积累太多垃圾代码就不好玩了.</li>
<li>随时考虑代码结构的性能,而尽量把底层优化推后.</li>
<li>重构不必过于追求完美 (处女座退散</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">一些通用设计模式</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
下面这几个模式大家都比较熟,也并不仅被应用于游戏开发中,在这里就不展开介绍了.
</p>
<ul class="org-ul">
<li>命令模式(Command)</li>
<li>享元模式(Flyweight)</li>
<li>观察者模式(Observer)</li>
<li>原型(Prototype)</li>
<li>单例(Singleton)</li>
<li>状态(State)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">用于时序的模式 (Sequencing Patterns)</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
(乍一看标题可能不太好理解, 撸主当初还以为是Sequence Queue之类的东西, 真是too young..)
</p>

<p>
简而言之, 所有需要one by one处理一坨事务的行为模式都可以称为sequencing patterns. 这里介绍三种.
</p>
</div>
<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">双缓冲 Double buffer</h3>
<div class="outline-text-3" id="text-orgheadline8">
</div><div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">目的</h4>
<div class="outline-text-4" id="text-orgheadline4">
<p>
使得一系列有序操作得以迅速且 <b>平滑</b> 的进行.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline5">
<p>
了解引擎的同学应该对这个概念比较熟悉. 双缓冲应用比较广的一个场景是在Rendering阶段:
</p>

<p>
渲染好的像素首先输出到frame buffer, 然后buffer中的内容会被输出到显示设备.
如果只有一个buffer, 会出现边更新边输出的状况, 显示设备上画面可能会出现撕裂. 双缓冲和三缓冲等技术是为了避免这个问题:
使用两个buffer来储存渲染画面. 分别为 back buffer 和 front buffer. 当front buffer被输出时, 下一帧的数据被放在back buffer中. front输出完毕后交换两个buffer.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">何时用</h4>
<div class="outline-text-4" id="text-orgheadline6">
<ul class="org-ul">
<li>需要频繁的改变一些状态</li>
<li>需要在改变时访问状态</li>
<li>状态改变在进行时禁止被代码访问</li>
<li>而代码不希望等到改变结束才能访问</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline7">
<ul class="org-ul">
<li>交换操作必须是原子的</li>
<li>它会增加内存占用</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">游戏循环 Game loop</h3>
<div class="outline-text-3" id="text-orgheadline13">
</div><div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">目的</h4>
<div class="outline-text-4" id="text-orgheadline9">
<p>
将游戏速度与用户输入及处理器速度解耦,并且使我们能够操控游戏速度.
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
这货对很多人来说太熟悉了,就是常用的Update方法嘛. 
</p>

<p>
游戏循环在游戏运行过程中以一定速率(比如60fps)持续运行. 在每一次循环中, 程序需要响应用户输入, 更新游戏状态, 以及进行图形渲染
(为了同时保证游戏的流畅性和时效性, 这些的操作一般不会互相阻塞, 而且运行频率也不同). 通过游戏循环, 我们可以方便的控制游戏的进行速度.
</p>

<p>
奉上unity的game loop作为参考,内有漂亮的图: <a href="http://docs.unity3d.com/Manual/ExecutionOrder.html">http://docs.unity3d.com/Manual/ExecutionOrder.html</a>
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">何时用</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
一般不需要自己造轮子, 它是如此重要, 以至于游戏引擎都把它视为不可分割的一部分.
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline12">
<ul class="org-ul">
<li>性能至关重要. 如果说一个程序花费90%的时间在10%的代码上,那Game Loop无疑就是这10%部分,所以需要额外关注它的性能.</li>
<li>在有些平台上, GameLoop可能需要与平台内嵌的UI/Event Loop和谐相处,这听起来就很蛋疼. 好在最近流行的平台上不容易碰到这个问题,或者已经被引擎处理好了.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">更新 Update</h3>
<div class="outline-text-3" id="text-orgheadline18">
</div><div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14">目的</h4>
<div class="outline-text-4" id="text-orgheadline14">
<p>
每帧逐一通知自己所管理的物件前进一帧, 以此驱动这些物件的行为.
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline15">
<p>
维护一个对象集合.每个对象实现一个更新的方法,模拟一帧对象的行为,每帧游戏逐一调用每一个对象的更新方法.
</p>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16">何时用</h4>
<div class="outline-text-4" id="text-orgheadline16">
<ul class="org-ul">
<li>有GameLoop的地方就可以用, 尤其当需要同步的物件特别多时.</li>
<li>每个物件的行为模式相对独立.</li>
<li>物件的行为依赖于时间.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline17">
<ul class="org-ul">
<li>把逻辑分散到众多对象中后, 代码结构会变得更离散,更复杂.</li>
<li>处理游戏暂停变的更难了, 返回游戏时需要恢复update之前的运行状态, 比如继续之前未完的遍历.</li>
<li>写下茫茫多的update调用之后, 往往会发现这些语句之间有时序依赖, 需要格外当心.</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19">用于实现行为的模式</h2>
<div class="outline-text-2" id="text-orgheadline19">
<p>
游戏中总是有许多特定的'行为', 比如怪物的AI, 技能, 对话等等. 
读书的时候时曾经为此写过一个几百行的switch-case, 用某个小伙伴的话讲就是"你会发现滚动条越来越小最后接近一个像素", 这显然不是正确的姿势_(:з」∠)_ <br  />
下面三种模式可以帮助你从switch-case中解脱出来.
</p>
</div>

<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">数据驱动 Bytecode</h3>
<div class="outline-text-3" id="text-orgheadline24">
</div><div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20">目的</h4>
<div class="outline-text-4" id="text-orgheadline20">
<p>
使用运行在'虚拟机'上,依靠解释执行的指令实现行为, 以提供最大的灵活性.
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline21">
<p>
上面那句话有些formal, 在实践中应该每个项目多少都用到这个模式, 比如用lua写一部分游戏逻辑(甚至所有逻辑.. <br  />
Lua是使用最广泛的register-based bytecode VM. 它除了能帮助我们将行为逻辑设计与需要编译的代码解耦, 还可以用于进行手机平台的热更新(苹果爸爸暂且认为lua属于"resource"), 所以lua几乎是现在手游的标配了.
</p>

<p>
Bytecode当然不仅限于脚本语言.推广一些,只要定义一套命令并在游戏中实现解析逻辑,能够在运行时解释执行就可以.
比如用xml定义一些简单的配置,用于制作新手引导,剧情对白等需要策划大量介入的环节.
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">何时用</h4>
<div class="outline-text-4" id="text-orgheadline22">
<p>
这个模式比较重度, 一个语言解释器自身的体积,和它对运行效率的影响都难以忽略. 所以仅当你有许多'行为'需要定义和维护的时候再考虑使用它.
</p>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline23">
<ul class="org-ul">
<li>现在是个好时代,就别自己去造轮子实现新的语言了,这可能对接盘侠们造成成吨的伤害.</li>
<li>解释执行使得运行效率打折扣.比如众所周知在unity中使用lua会带来一些性能损失,虽然这点损失远远比不上它带来的好处.</li>
<li>难以调试. 撸主曾经在写了一段时间lua后练就了不依赖debugger的习惯.</li>
<li>难以信任. 保证脚本质量和追踪脚本错误都比平时麻烦一些.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">子类沙箱 Subclass Sandbox</h3>
<div class="outline-text-3" id="text-orgheadline29">
</div><div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25">目的</h4>
<div class="outline-text-4" id="text-orgheadline25">
<p>
使基类成为沙箱, 在子类中仅使用基类提供的方法定义行为.
</p>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline26">
<p>
当有许多同类行为(例如许多技能)需要实现时,首先被想到的方法可能是定义一大堆类. <br  />
随之而来的问题则是大量重复冗余的代码,大量对外界api(音频,动画)的调用,难以定义统一的行为.
</p>

<p>
Subclass Sandbox模式解决这个问题的思路是:<br  />
使基类成为一个沙箱,封装一些通用的操作以及对子系统外部的调用在其中, 子类仅使用基类提供的接口来实现一系列相似的行为.
</p>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27">何时用</h4>
<div class="outline-text-4" id="text-orgheadline27">
<p>
这是一个非常轻量的模式,想用就用,尤其当遇到以下情景时:
</p>
<ul class="org-ul">
<li>当你发现需要定义一大坨子类,并且基类可以提供子类所需的所有操作,且子类之间需要共享一些操作.</li>
<li>希望把子系统与外界隔离时.(尼玛引擎升级以后XX函数被deprecated了啊! 有几百个地方要改呢要死了!</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-4">
<h4 id="orgheadline28">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline28">
<ul class="org-ul">
<li>首先,这个基类沙盒看起来就很长,它很好的诠释了解耦和代码量的关系...</li>
<li>难以改动基类, 详情见此<a href="https://en.wikipedia.org/wiki/Fragile_base_class">Fragile base class</a></li>
<li>如果基类实在是太庞大,可以考虑使用Component模式,把一些相对独立的操作抽离.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34">类型对象 Type Object</h3>
<div class="outline-text-3" id="text-orgheadline34">
</div><div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30">目的</h4>
<div class="outline-text-4" id="text-orgheadline30">
<p>
定义一个类,这个类的每个实例可以代表一种不同类型的物体.
</p>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline31">
<p>
有天策划想要实现一只怪, 程序猿马上实现了Monster. <br  />
第二天策划说"一种怪太单调了,来七八种吧", 程序猿咬咬牙, 从Monster继承了8个XXXMonster. <br  />
第三天策划又想出了80种怪, 第四天策划要把所有怪的数值调一遍... <br  />
</p>

<p>
如果程序猿还坚持用标准的oop解法肯定是要死人的, Type Object模式就应运而生了: <br  />
定义一个'容器'类, 再定义一个'类型'类. '容器'类中实现操作, '类型'类包含描述和数据. 使'容器'类拥有一个'类型'类的引用, 在需要向'类型'类查询数据. is-a变成has-a.<br  />
再进一步,'类型'类可以优化成数据驱动的, 策划就可以随心所欲的折腾了.
</p>

<p>
以上面的场景举栗, 把Monster作为'容器'类:
</p>
<div class="org-src-container">

<pre class="src src-c++">class Monster
{
public:
  Monster(Breed&amp; breed)
  : health_(breed.getHealth()),
    breed_(breed)
  {}
  const char* getAttack()
  {
    return breed_.getAttack();
  }
private:
  int    health_;
  Breed&amp; breed_;
};
</pre>
</div>
<p>
另外定义'Breed'作为'类型'类:
</p>
<div class="org-src-container">

<pre class="src src-c++">class Breed
{
public:
  Breed(int health, const char* attack)
  : health_(health),
    attack_(attack)
  {}
  int getHealth() { return health_; }
  const char* getAttack() { return attack_; }
private:
  int health_;
  const char* attack_;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32">何时用</h4>
<div class="outline-text-4" id="text-orgheadline32">
<p>
这个模式略显厚重,毕竟多了一层'类'. 出现以下状况时可以考虑使用它:
</p>
<ul class="org-ul">
<li>不知道策划在梦里还会开什么脑洞.</li>
<li>希望不重新编译代码就能进行改动.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline33">
<p>
使用这个模式后往往会把一些内容放在配置中,虽然增加了灵活度,但会失去一些操控性. <br  />
"哎呀这个怪的冒字动画能不能稍微特别一点, 要不再给那个怪额外加两个音效", "(╯‵□′)╯︵┻━┻"
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline35" class="outline-2">
<h2 id="orgheadline35">用于解耦的模式</h2>
<div class="outline-text-2" id="text-orgheadline35">
<p>
码代码容易, 应付日新月异的需求难, 解耦可以让生活轻松一点点.
</p>
</div>

<div id="outline-container-orgheadline40" class="outline-3">
<h3 id="orgheadline40">组件 Component</h3>
<div class="outline-text-3" id="text-orgheadline40">
</div><div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36">目的</h4>
<div class="outline-text-4" id="text-orgheadline36">
<p>
允许一个实体应用在多种互相无耦合的域中.
</p>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-4">
<h4 id="orgheadline37">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline37">
<p>
熟悉Unity的同学有木有亲切..没错,Unity框架的核心GameObject就是根据这个思路设计的, 可以说此Component即彼Component.
</p>

<p>
这个模式即: 一个Component可以被应用在多个实体中。为了使实体保持无耦合, 逻辑代码分散到各自的Component中, 实体蜕化为一个存放Component的集合.
</p>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38">何时用</h4>
<div class="outline-text-4" id="text-orgheadline38">
<ul class="org-ul">
<li>当你希望你的类包含许多不同种类且互相独立的功能时.</li>
<li>如果你的类开始变得非常庞大繁杂,这个模式可能能够帮到忙.</li>
<li>当你想定义许多不同的类,他们共享一些操作, 但是仅仅靠继承满足不了需求.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline39">
<ul class="org-ul">
<li>复杂, 还是复杂. 使用这个模式不仅仅意味着添加许多Component类, 更要关心它们怎样聚合在一起. 现实总是残酷地, 这些Component往往不可能做到完全的独立, 总是藕断丝连的共享一些状态.
有时需要把状态放在容器中, 有时需要Component互相了解对方的细节, 需要自行权衡.</li>
<li>使用不便. unity程序猿们一定对没完没了的GetComponent怨念颇深吧-v-</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-3">
<h3 id="orgheadline45">消息队列 Event Queue</h3>
<div class="outline-text-3" id="text-orgheadline45">
</div><div id="outline-container-orgheadline41" class="outline-4">
<h4 id="orgheadline41">目的</h4>
<div class="outline-text-4" id="text-orgheadline41">
<p>
将消息/事件的发送者和接收者解耦
</p>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-4">
<h4 id="orgheadline42">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline42">
<p>
队列按照先进先出顺序存储一系列消息,并发送通知,处理者收到通知后在队列中取出感兴趣的消息,并把它路由到特定的地方.这样可以将消息的发送者和接收者解耦.
</p>

<p>
它有许多别名,诸如“message queue”,“event loop”, “message pump”, 不陌生吧.
</p>
</div>
</div>

<div id="outline-container-orgheadline43" class="outline-4">
<h4 id="orgheadline43">何时用</h4>
<div class="outline-text-4" id="text-orgheadline43">
<p>
如果仅仅是为了解耦消息发送者和接收者, 观察者模式和命令模式都可以满足需求, 而且代价更小. 但上述两种模式都是实时的, 消息队列则允许使用者挑选一个方便的时间处理事务.
</p>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-4">
<h4 id="orgheadline44">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline44">
<ul class="org-ul">
<li>一旦在使用了这个模式,它的影响面会非常大, 游戏中消息满天飞. 设计时要格外谨慎.</li>
<li>event queue通常是 <b>全局</b> 的</li>
<li>当心无限循环. 比如:出现消息A, 函数B响应了它, 做了一些事情之后函数B又抛出了一个消息A...</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-3">
<h3 id="orgheadline50">服务定位 Service Locator</h3>
<div class="outline-text-3" id="text-orgheadline50">
</div><div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46">目的</h4>
<div class="outline-text-4" id="text-orgheadline46">
<p>
提供无耦合的全局的服务.
</p>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47">模式简介</h4>
<div class="outline-text-4" id="text-orgheadline47">
<p>
游戏引擎中有些基础功能需要随时随地被访问, 比如音频播放, 动效播放, 配置读取, 等等.
我们一般程序猿常用的手段是用单例来实现某个"Center","Manager"或者"System", 然后在游戏里随意的使用.这存在一些问题:
</p>
<ul class="org-ul">
<li>没有很好的解耦.</li>
<li>这些Center,Manager,System难以被整体的替换.</li>
</ul>

<p>
Service Locator模式提供了一个灵活一些的思路:
一个服务类定义了一个抽象接口的一组操作。一个具体的服务提供者实现这个接口。服务定位器(Service Locator)根据调用者需要的类型来提供对服务的访问.
</p>

<p>
此处需要祭出一些代码:
</p>
<div class="org-src-container">

<pre class="src src-c++">class ConsoleAudio : public Audio
{
public:
  virtual void playSound(int soundID)
  {
    // Play sound using console audio api...
  }
  virtual void stopSound(int soundID)
  {
    // Stop sound using console audio api...
  }
};

class Locator
{
public:
  static Audio* getAudio() { return service_; }

  static void provide(Audio* service)
  {
    service_ = service;
  }

private:
  static Audio* service_;
};
</pre>
</div>

<p>
在给整个游戏使用之前, 首先需要通过外界来'注册'一个服务, 这个服务可以随时更换, 只需实现接口即可 (所以完全可以实现一个什么也不干的null service
</p>
<div class="org-src-container">

<pre class="src src-c++">ConsoleAudio *audio = new ConsoleAudio();
Locator::provide(audio);

// 使用者只需知道协议的接口
Audio *audio = Locator::getAudio();
audio-&gt;playSound(VERY_LOUD_BANG);
</pre>
</div>

<p>
另外一个更加喜闻乐见的例子:
Unity的GetComponent&lt;&gt;()方法
</p>
</div>
</div>

<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48">何时用</h4>
<div class="outline-text-4" id="text-orgheadline48">
<p>
慎用.
许多子系统几乎不需要"灵活的替换", 那么一个单例就足够了, 无须把它们隐藏在层层叠叠的代码之后.
反之, 当一个系统需要频繁替换或拆卸时, 不妨试试这个模式...比如打Log.
</p>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline49">
<ul class="org-ul">
<li>灵活性和复杂度之间的权衡是永恒的话题, 有时单例足够满足需求.</li>
<li>需要确保服务在合适的地方被初始化和配置.</li>
<li>服务必须足够健壮, 要有在任何环境下, 被任何人调用的觉悟.</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline51" class="outline-2">
<h2 id="orgheadline51">用于优化性能的模式</h2>
<div class="outline-text-2" id="text-orgheadline51">
<p>
性能'优化'是个永恒的课题, 下面介绍四个以空间换时间的模式.
</p>
</div>

<div id="outline-container-orgheadline56" class="outline-3">
<h3 id="orgheadline56">Data Locality</h3>
<div class="outline-text-3" id="text-orgheadline56">
</div><div id="outline-container-orgheadline52" class="outline-4">
<h4 id="orgheadline52">目的</h4>
</div>
<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53">模式简介</h4>
</div>
<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54">何时用</h4>
</div>
<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55">安全食用指南</h4>
</div>
</div>

<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61">Dirty Flag</h3>
<div class="outline-text-3" id="text-orgheadline61">
</div><div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57">目的</h4>
</div>
<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58">模式简介</h4>
</div>
<div id="outline-container-orgheadline59" class="outline-4">
<h4 id="orgheadline59">何时用</h4>
</div>
<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60">安全食用指南</h4>
</div>
</div>

<div id="outline-container-orgheadline66" class="outline-3">
<h3 id="orgheadline66">Object Pool</h3>
<div class="outline-text-3" id="text-orgheadline66">
</div><div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62">目的</h4>
</div>
<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63">模式简介</h4>
</div>
<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64">何时用</h4>
</div>
<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65">安全食用指南</h4>
</div>
</div>

<div id="outline-container-orgheadline71" class="outline-3">
<h3 id="orgheadline71">Spatial Partition</h3>
<div class="outline-text-3" id="text-orgheadline71">
</div><div id="outline-container-orgheadline67" class="outline-4">
<h4 id="orgheadline67">目的</h4>
</div>
<div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68">模式简介</h4>
</div>
<div id="outline-container-orgheadline69" class="outline-4">
<h4 id="orgheadline69">何时用</h4>
</div>
<div id="outline-container-orgheadline70" class="outline-4">
<h4 id="orgheadline70">安全食用指南</h4>
<div class="outline-text-4" id="text-orgheadline70">
<p>
写到最后感到简直是把原书的目录给翻译了一遍, 忧桑... 
</p>

<p>
虽然如此, 还是希望这篇文章能够在15分钟内给低年级同学一个关于游戏模式的大概印象, 或者帮助中高年级同学整理一下知识结构, 如有同学发现错误求尽快指正
</p>

<p>
最后说句自己的感受...设计模式打嘴炮容易应用难,需要时刻以强大的意志力保证在应付繁杂的需求的同时保持敏感,克服惯性,克服懒,愿圣光护佑着你...
</p>
</div>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2016-05-17</span>
        <span title="last modification date" class="post-info">2016-06-25</span>
        <span title="tags" class="post-info"><a href="/tags/reading-note/">reading note</a></span>
        <span title="author" class="post-info">Tsubasa</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2016/05/17/game-programming-patterns-reading-note";
          var disqus_url = "http://tsubasawp.github.io/blog/2016/05/17/game-programming-patterns-reading-note";
          var disqus_shortname = 'Tsubasa';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <div class="ds-thread"></div>
        <script type="text/javascript">
          var duoshuoQuery = {short_name:'Tsubasa'};
          (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = 'http://static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
          || document.getElementsByTagName('body')[0]).appendChild(ds);
          })();
        </script>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:Tsubasa &lt;at&gt; Tsubasas-MacBook-Pro &lt;dot&gt; local">Tsubasa</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
